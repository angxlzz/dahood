--[[ hello very cool incognito / solara (mostly incognito because solara has most of these functions, just not all) btw please showcase this script and make sure to join https://discord.gg/BkTebksHgr for more scripts like these!! 
pls dont steal source code :( ]]
local bit = bit32
function ToEnum(a)
 for i, v in pairs(Enum.KeyCode:GetEnumItems()) do if tostring(v) == a then return v end end
end
local Functions = {}
local keys={[0x08]=Enum.KeyCode.Backspace,[0x09]=Enum.KeyCode.Tab,[0x0C]=Enum.KeyCode.Clear,[0x0D]=Enum.KeyCode.Return,[0x10]=Enum.KeyCode.LeftShift,[0x11]=Enum.KeyCode.LeftControl,[0x12]=Enum.KeyCode.LeftAlt,[0x13]=Enum.KeyCode.Pause,[0x14]=Enum.KeyCode.CapsLock,[0x1B]=Enum.KeyCode.Escape,[0x20]=Enum.KeyCode.Space,[0x21]=Enum.KeyCode.PageUp,[0x22]=Enum.KeyCode.PageDown,[0x23]=Enum.KeyCode.End,[0x24]=Enum.KeyCode.Home,[0x2D]=Enum.KeyCode.Insert,[0x2E]=Enum.KeyCode.Delete,[0x30]=Enum.KeyCode.Zero,[0x31]=Enum.KeyCode.One,[0x32]=Enum.KeyCode.Two,[0x33]=Enum.KeyCode.Three,[0x34]=Enum.KeyCode.Four,[0x35]=Enum.KeyCode.Five,[0x36]=Enum.KeyCode.Six,[0x37]=Enum.KeyCode.Seven,[0x38]=Enum.KeyCode.Eight,[0x39]=Enum.KeyCode.Nine,[0x41]=Enum.KeyCode.A,[0x42]=Enum.KeyCode.B,[0x43]=Enum.KeyCode.C,[0x44]=Enum.KeyCode.D,[0x45]=Enum.KeyCode.E,[0x46]=Enum.KeyCode.F,[0x47]=Enum.KeyCode.G,[0x48]=Enum.KeyCode.H,[0x49]=Enum.KeyCode.I,[0x4A]=Enum.KeyCode.J,[0x4B]=Enum.KeyCode.K,[0x4C]=Enum.KeyCode.L,[0x4D]=Enum.KeyCode.M,[0x4E]=Enum.KeyCode.N,[0x4F]=Enum.KeyCode.O,[0x50]=Enum.KeyCode.P,[0x51]=Enum.KeyCode.Q,[0x52]=Enum.KeyCode.R,[0x53]=Enum.KeyCode.S,[0x54]=Enum.KeyCode.T,[0x55]=Enum.KeyCode.U,[0x56]=Enum.KeyCode.V,[0x57]=Enum.KeyCode.W,[0x58]=Enum.KeyCode.X,[0x59]=Enum.KeyCode.Y,[0x5A]=Enum.KeyCode.Z,[0x5D]=Enum.KeyCode.Menu,[0x60]=Enum.KeyCode.KeypadZero,[0x61]=Enum.KeyCode.KeypadOne,[0x62]=Enum.KeyCode.KeypadTwo,[0x63]=Enum.KeyCode.KeypadThree,[0x64]=Enum.KeyCode.KeypadFour,[0x65]=Enum.KeyCode.KeypadFive,[0x66]=Enum.KeyCode.KeypadSix,[0x67]=Enum.KeyCode.KeypadSeven,[0x68]=Enum.KeyCode.KeypadEight,[0x69]=Enum.KeyCode.KeypadNine,[0x6A]=Enum.KeyCode.KeypadMultiply,[0x6B]=Enum.KeyCode.KeypadPlus,[0x6D]=Enum.KeyCode.KeypadMinus,[0x6E]=Enum.KeyCode.KeypadPeriod,[0x6F]=Enum.KeyCode.KeypadDivide,[0x70]=Enum.KeyCode.F1,[0x71]=Enum.KeyCode.F2,[0x72]=Enum.KeyCode.F3,[0x73]=Enum.KeyCode.F4,[0x74]=Enum.KeyCode.F5,[0x75]=Enum.KeyCode.F6,[0x76]=Enum.KeyCode.F7,[0x77]=Enum.KeyCode.F8,[0x78]=Enum.KeyCode.F9,[0x79]=Enum.KeyCode.F10,[0x7A]=Enum.KeyCode.F11,[0x7B]=Enum.KeyCode.F12,[0x90]=Enum.KeyCode.NumLock,[0x91]=Enum.KeyCode.ScrollLock,[0xBA]=Enum.KeyCode.Semicolon,[0xBB]=Enum.KeyCode.Equals,[0xBC]=Enum.KeyCode.Comma,[0xBD]=Enum.KeyCode.Minus,[0xBE]=Enum.KeyCode.Period,[0xBF]=Enum.KeyCode.Slash,[0xC0]=Enum.KeyCode.Backquote,[0xDB]=Enum.KeyCode.LeftBracket,[0xDD]=Enum.KeyCode.RightBracket,[0xDE]=Enum.KeyCode.Quote}
local funcs, names = {}, {}
local c = 1

local vim = game:GetService('VirtualInputManager');
function _BLANK() end
function DescendantCount(tbl)
    local count = 0
    if type(tbl) ~= 'table' then 
        return 1 
    end
    for _, v in pairs(tbl) do
        count = count + 1
        if type(v) == 'table' then
            count = count + DescendantCount(v)
        end
    end
    return count
end


function Descendants(tbl)
    local descendants = {}
    
    local function process_table(subtbl, prefix)
        for k, v in pairs(subtbl) do
            local index = prefix and (prefix .. "." .. tostring(k)) or tostring(k)
            descendants[index] = v  -- Include the table itself
            if type(v) == 'table' then
                process_table(v, index)
            else
                descendants[index] = v
            end
        end
    end

    if type(tbl) ~= 'table' then
        descendants[tostring(1)] = tbl
    else
        process_table(tbl, nil)
    end
    
    return descendants
end




local Debug = loadstring(game:HttpGet('https://rawscripts.net/raw/Universal-Script-Basic-Functions-12707'))()

--[[ Libraries ]]


funcs.base64 = {}
funcs.crypt = {hex={},url={}}
funcs.syn = {}
funcs.syn_backup = {}
funcs.http = {}
funcs.Drawing = {}
funcs.Vector2 = table.clone(Vector2) -- [[ Extra vector2 functions for scaling. ]]

funcs.Drawing.Fonts = {
  ['UI'] = 0,
  ['System'] = 1,
  ['Plex'] = 2,
  ['Monospace'] = 3
}
local Fonts = {
 [0] = Enum.Font.Arial,
 [1] = Enum.Font.BuilderSans,
 [2] = Enum.Font.Gotham,
 [3] = Enum.Font.RobotoMono
}

local drawingHistory = {}
local DrawingDict = Instance.new("ScreenGui")

-- [[ Functions ]]
funcs.Vector2.rel = function(x, y)
 local size = workspace.CurrentCamera.ViewportSize
 return Vector2.new(size.X * x, size.Y * y)
end
funcs.Vector2.relx = function(x)
 return workspace.CurrentCamera.ViewportSize.X * x
end
funcs.Vector2.rely = function(y)
 return workspace.CurrentCamera.ViewportSize.Y * y
end
funcs.Vector2.fromRel = funcs.Vector2.rel
funcs.Vector2.scale = funcs.Vector2.rel
funcs.Vector2.fromScale = funcs.Vector2.rel

funcs.clonefunction = function(a)
 return function(...)
  return a(...)
 end
end
funcs.cloneref = function(a) -- [[ Not a real cloneref but works]
 local s, _ = pcall(function() return a:Clone() end) return s and _ or a
end
funcs.deepclone = function(a)
 local Result = {}
 for i, v in pairs(a) do
  if type(v) == 'table' then
    Result[i] = funcs.deepclone(v)
  end
  Result[i] = v
 end
 return Result
end
getgenv = getgenv or getfenv(2)
function SafeOverride(a, b, c) --[[ Index, Data, Should override ]]
 if getgenv()[a] and not c then return 1 end
 getgenv()[a] = b
 return 2
end
--[[ The base64 functions were made by https://scriptblox.com/u/yofriendfromschool1 , Credits to him.]]
funcs.base64.encode = function(data)
    local letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return letters:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end
funcs.base64.decode = function(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if x == '=' then return '' end
        local r, f = '', (b:find(x) - 1)
        for i = 6, 1, -1 do
            r = r .. (f % 2^i - f % 2^(i - 1) > 0 and '1' or '0')
        end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if #x ~= 8 then return '' end
        local c = 0
        for i = 1, 8 do
            c = c + (x:sub(i, i) == '1' and 2^(8 - i) or 0)
        end
        return string.char(c)
    end))
end

funcs.loadstring = loadstring
funcs.getgenv = getgenv
funcs.crypt.base64 = funcs.base64
funcs.crypt.base64encode = funcs.base64.encode
funcs.crypt.base64decode = funcs.base64.decode
funcs.crypt.base64_encode = funcs.base64.encode
funcs.crypt.base64_decode = funcs.base64.decode
funcs.base64_encode = funcs.base64.encode
funcs.base64_decode = funcs.base64.decode

funcs.crypt.hex.encode = function(txt)
 txt = tostring(txt)
 local hex = ''
 for i = 1, #txt do
    hex = hex .. string.format("%02x", string.byte(txt, i))
 end
 return hex
end
funcs.crypt.hex.decode = function(hex)
    hex = tostring(hex)
    local text = ""
    for i = 1, #hex, 2 do
        local byte_str = string.sub(hex, i, i+1)
        local byte = tonumber(byte_str, 16)
        text = text .. string.char(byte)
    end
    return text
end
funcs.crypt.url.encode = function(a)
 return game:GetService("HttpService"):UrlEncode(a)
end
funcs.crypt.url.decode = function(a)
    a = tostring(a)
    a = string.gsub(a, "+", " ")
    a = string.gsub(a, "%%(%x%x)", function(hex)
        return string.char(tonumber(hex, 16))
    end)
    a = string.gsub(a, "\r\n", "\n")
    return a
end
funcs.crypt.generatekey = function(optionalSize)
 local key = ''
 local a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
 for i = 1, optionalSize or 32 do local n = math.random(1, #a) key = key .. a:sub(n, n) end
 return funcs.base64.encode(key)
end
funcs.crypt.generatebytes = function(size)
 if type(size) ~= 'number' then return error('missing arguement #1 to \'generatebytes\' (number expected)') end
 return funcs.crypt.generatekey(size)
end
--[[ Basic XOR encryption because i don't know wtf synapse uses for crypt.encrypt ]]
funcs.crypt.encrypt = function(a, b)
 local result = {}
 a = tostring(a) b = tostring(b)
 for i = 1, #a do
    local byte = string.byte(a, i)
    local keyByte = string.byte(b, (i - 1) % #b + 1)
    table.insert(result, string.char(bit32.bxor(byte, keyByte)))
 end
 return table.concat(result)
end
funcs.crypt.decrypt = funcs.crypt.encrypt
funcs.crypt.random = function(len)
 assert(type(len)~='number', 'invalid arguement #1 to \'random\', number expected got ' .. type(len))
 return funcs.crypt.generatekey(len)
end

local active = true
game:GetService("UserInputService").WindowFocused:Connect(function()
 active = true
end)

game:GetService("UserInputService").WindowFocusReleased:Connect(function()
 active = false
end)

funcs.isrbxactive = function()
 return active
end
funcs.isgameactive = funcs.isrbxactive
funcs.gethui = function()
 local s, H = pcall(function()
  return game:GetService("CoreGui")
 end)
 return s and H or game:GetService("Players").LocalPlayer.PlayerGui
end
funcs.setclipboard = function(data)
    local old = game:GetService("UserInputService"):GetFocusedTextBox()
    local copy = tostring(data)
    local gui = Instance.new("ScreenGui", getgenv().gethui())
    local a = Instance.new('TextBox', gui)
    a.PlaceholderText = ''
    a.Text = copy
    a.ClearTextOnFocus = false
    a.Size = UDim2.new(.1, 0, .15, 0)
    a.Position = UDim2.new(10, 0, 10, 0)
    a:CaptureFocus()
    a = Enum.KeyCode
    local Keys = {
     a.RightControl, a.A
    }
    local Keys2 = {
     a.RightControl, a.C, a.V
    }
    for i, v in ipairs(Keys) do
     vim:SendKeyEvent(true, v, false, game)
     task.wait()
    end
    for i, v in ipairs(Keys) do
     vim:SendKeyEvent(false, v, false, game)
     task.wait()
    end
    for i, v in ipairs(Keys2) do
     vim:SendKeyEvent(true, v, false, game)
     task.wait()
    end
    for i, v in ipairs(Keys2) do
     vim:SendKeyEvent(false, v, false, game)
     task.wait()
    end
    gui:Destroy()
    if old then old:CaptureFocus() end
end
funcs.syn.write_clipboard = funcs.setclipboard
funcs.toclipboad = funcs.setclipboard
funcs.setrbxclipboard = funcs.setclipboard

funcs.syn.protect_gui = function(gui) -- Does not actually protect it, just parents to gethui and renames the gui to a roblox gui.
 names[gui] = {name=gui.Name,parent=gui.Parent}
 if getgenv().gethui() == game:GetService("Players").LocalPlayer.PlayerGui then
  gui.Name = 'Chat'
 else
  gui.Name = 'RobloxGui'
 end
 gui.Parent = getgenv().gethui()
end
funcs.syn.unprotect_gui = function(gui)
 if names[gui] then gui.Name = names[gui].name gui.Parent = names[gui].parent end
end
funcs.syn.secure_call = function(func) -- Does not do a secure call, just pcalls it.
 return pcall(func)
end


funcs.isreadonly = function(tbl)
 if type(tbl) ~= 'table' then return false end
 return table.isfrozen(tbl)
end
funcs.setreadonly = function(tbl, cond)
 if cond then
  table.freeze(tbl)
 else
  return funcs.deepclone(tbl)
 end
end
funcs.httpget = function(url)
 return game:HttpGet(url)
end
funcs.httppost = function(url, body, contenttype)
 return game:HttpPostAsync(url, body, contenttype)
end
funcs.request = function(args)
 if args.Method == 'GET' then
  local result = {}
  local s, getresult = pcall(function() return funcs.httpget(args.Url) end)
  result.Body = s and getresult or ''
  result.Success = s
  result.StatusCode = s and 200 or 400 -- Inaccurate but works i guess?
  return result
 elseif args.Method == 'POST' then
  local result = {}
  local s, r = pcall(function() return funcs.httppost(args.Url, args.Body or '', args.Headers and args.Headers['Content-Type'] and args.Headers['Content-Type'] or 'application/x-www-form-urlencoded') end)
  result.Success = s
  result.Body = r
  result.StatusCode = s and 200 or 400 -- Inaccurate but works i guess?
  return result
 else
  print('script tried to send an http request with a non implemented method',args.Method)
  return {Success=false,StatusCode=404} -- 404 means not found which can cause some errors in scripts.
 end
end
funcs.newcclosure = function(func) -- This is a horrible attempt at making newcclosure but it is practically impossible in luau (or so i think)
 return function(...)
  func(...)
 end
end
funcs.mouse1click = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, true, game, false)
 task.wait()
 vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end
funcs.mouse2click = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, true, game, false)
 task.wait()
 vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end
funcs.mouse1press = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, true, game, false)
end
funcs.mouse1release = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end
funcs.mouse2press = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, true, game, false)
end
funcs.mouse2release = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end
funcs.mousescroll = function(x, y, a)
 x = x or 0
 y = y or 0
 a = a and true or false
 vim:SendMouseWheelEvent(x, y, a, game)
end
funcs.keyclick = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(true, keys[key], false, game)
 task.wait()
 vim:SendKeyEvent(false, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(true, key, false, game)
  task.wait()
  vim:SendKeyEvent(false, key, false, game)
 end
end
funcs.keypress = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(true, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(true, key, false, game)
 end
end
funcs.keyrelease = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(false, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(false, key, false, game)
 end
end
funcs.mousemoverel = function(relx, rely)
 local Pos = workspace.CurrentCamera.ViewportSize
 relx = relx or 0
 rely = rely or 0
 local x = Pos.X * relx
 local y = Pos.Y * rely
 vim:SendMouseMoveEvent(x, y, game)
end
funcs.mousemoveabs = function(x, y)
 x = x or 0 y = y or 0
 vim:SendMouseMoveEvent(x, y, game)
end

funcs.isexecutorclosure = function(fnc)
 return Functions[fnc] and true or false
end

--[[ File system is something i do not know how to implement in roblox lua.
UPDATE AT 18/5/2024:
I figured out i can use temp file system.
]]
local files = {}

local function MakeFile(name, content)
    local Folders = name:split('/')
    local FileName = table.remove(Folders)
    local currentFolder = files
    
    for _, FolderName in ipairs(Folders) do
        if not currentFolder[FolderName] then
            currentFolder[FolderName] = {}
        end
        currentFolder = currentFolder[FolderName]
    end
    
    currentFolder[FileName] = content
end

local function getPath(name)
    local Folders = name:split('/')
    local currentFolder = files
    
    for _, FolderName in ipairs(Folders) do
        currentFolder = currentFolder[FolderName]
        if not currentFolder then
            return nil
        end
    end
    
    return currentFolder
end

funcs.writefile = function(name, content)
    local success, err = pcall(function()
        name = tostring(name)
        content = tostring(content)
        MakeFile(name, content)
    end)
    if not success then error('file error: ' .. err) end
end

funcs.makefolder = function(name)
    local success, err = pcall(function()
        name = tostring(name)
        MakeFile(name, {})
    end)
    if not success then error('file error: ' .. err) end
end

funcs.readfile = function(name)
    local Folders = name:split('/')
    local FileName = table.remove(Folders)
    local currentFolder = files
    
    for _, FolderName in ipairs(Folders) do
        currentFolder = currentFolder[FolderName]
        if not currentFolder then
            return nil
        end
    end
    
    return currentFolder[FileName]
end

funcs.delfile = function(name)
    local success, err = pcall(function()
        local Folders = name:split('/')
        local FileName = table.remove(Folders)
        local currentFolder = files
        
        for _, FolderName in ipairs(Folders) do
            currentFolder = currentFolder[FolderName]
            if not currentFolder then
                return
            end
        end
        
        currentFolder[FileName] = nil
    end)
    if not success then error('file error: ' .. err) end
end

funcs.delfolder = function(name)
    local success, err = pcall(function()
        local Folders = name:split('/')
        local FolderName = table.remove(Folders)
        local currentFolder = files
        
        for _, FolderName in ipairs(Folders) do
            currentFolder = currentFolder[FolderName]
            if not currentFolder then
                return
            end
        end
        
        currentFolder[FolderName] = nil
    end)
    if not success then error('folder error: ' .. err) end
end

funcs.isfile = function(name)
    local path = getPath(name)
    return path ~= nil and type(path) ~= "table"
end

funcs.isfolder = function(name)
    local path = getPath(name)
    return path ~= nil and type(path) == "table"
end

funcs.listfiles = function(path)
    if path and path:sub(-1) == '/' then
        path = path:sub(1, -2)
    end

    local updated = {}
    local Files = path and getPath(path) or files
    
    if Files and type(Files) == "table" then
        for i, v in pairs(Files) do
            if v ~= nil then
                table.insert(updated, i)
            end
        end
    end
    
    return updated
end

funcs.loadfile = function(path)
    local fileContent = funcs.readfile(path)
    if fileContent then
        return loadstring(fileContent)
    else
        return error('file not found: ' .. path)
    end
end

funcs.appendfile = function(name, extra)
    local content = funcs.readfile(name)
    if content then
        MakeFile(name, content .. tostring(extra))
    else
        error('file not found: ' .. name)
    end
end


funcs.http.request = funcs.request
funcs.syn.crypt = funcs.crypt
funcs.syn.crypto = funcs.crypt
funcs.syn_backup = funcs.syn


funcs.getexecutorname = function()
 return 'MoreUNC', 1
end
funcs.identifyexecutor = funcs.getexecutorname
funcs.http_request = getgenv().request or funcs.request
funcs.getscripts = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("LocalScript") or v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.get_scripts = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("LocalScript") or v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.getmodules = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.make_readonly = funcs.setreadonly
funcs.makereadonly = funcs.setreadonly
funcs.base64encode = funcs.crypt.base64encode
funcs.base64decode = funcs.crypt.base64decode
funcs.clonefunc = funcs.clonefunction
funcs.getinstances = function()
 return game:GetDescendants()
end
funcs.iswriteable = function(tbl)
 return not table.isfrozen(tbl)
end
funcs.makewriteable = function(tbl)
 return
end

for _, con in next, getconnections(workspace.CurrentCamera.Changed) do
    task.wait()
      con:Disable()
  end
  for _, con in next, getconnections(workspace.CurrentCamera:GetPropertyChangedSignal("CFrame")) do
     task.wait()
      con:Disable()
  end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end;
    getgenv().fraudfun = {
        ['Startup'] = {
            Key = 'keyhere', -- replace key here with your luarmor key
            Intro = true, -- shows an intro on startup
            GUI = true, -- enables the gui, will drop fps a little
            NotificationMode = "Roblox", -- roblox, default (default broken on solara)
            ['FPS'] = {
                UnlockFPS = true, -- unlocks your fps
                FpsCap = 9999, -- max fps 
            },
        },
        ['Panic'] = {
            Enabled = false, -- will disable all features
            Keybind = "P", -- panic keybind
            PanicNotifications = true, -- notifys if you panic
        },
        ['Silent Aim'] = {
            Enabled = true, -- enables silent aim
            Mode = "FOV", -- FOV (normal silent), Target
            TargetBind = "C", -- bind for target mode
            TargetNotifications = false, -- notifys you when changed target
            ['Prediction'] = {
                Prediction = 0.14, -- prediction value
                HitChance = 100, -- chance to hit your target (0-100)
            },
            ['Hitpart'] = {
                Hitpart = "HumanoidRootPart", -- HumanoidRootPart, UpperTorso, LowerTorso, Head
                ClosetPart = false, -- uses closet hitpart, all parts supported
            },
            ['Visuals'] = {
                Dot = false, -- adds a dot to the target
                Tracer = false, -- adds a tracer to the target
            },
        },
        ['Aimlock'] = {
            Enabled = false, -- enables camlock
            Mode = "Target", -- FOV, Target (normal aimlock)
            TargetBind = "C", -- bind for target mode
            TargetNotifications = false, -- notifys you when changed target
            ['Prediction'] = {
                Prediction = 0.14, -- prediction value
                HitChance = 100, -- chance to hit your target (0-100)
                EasingStyle = "Exponential", -- https://create.roblox.com/docs/reference/engine/enums/EasingStyle
            },
            ['Hitpart'] = {
                Hitpart = "HumanoidRootPart", -- HumanoidRootPart, UpperTorso, LowerTorso, Head
                ClosetPart = false, -- uses closet hitpart, all parts supported
            },
            ['Smoothness'] = {
                Enabled = true, -- smooths the camlock, looks legit
                Amount = 0.065, -- smoothing amount
            },
            ['Visuals'] = {
                Dot = false, -- adds a dot to the target
                Tracer = false, -- adds a tracer to the target
            },
            ['Shake'] = {
                Enabled = false, -- shakes your camera on the target
                X = 5, -- shake x position
                Y = 5, -- shake y position
                Z = 5, -- shake z position
            }
        },
        ['Global'] = {
            AutoPrediction = true, -- automatically sets a prediction based on your ping
            Predictions = { -- if you set here, it wont show on gui. your predictions will still work
                Ping30 = 0.1099,
                Ping40 = 0.1195,
                Ping50 = 0.1219,
                Ping60 = 0.1237,
                Ping70 = 0.1291,
                Ping80 = 0.1337,
                Ping90 = 0.1349,
                Ping100 = 0.1378,
                Ping110 = 0.1459,
                Ping120 = 0.149,
                Ping130 = 0.151,
                Ping140 = 0.1652131,
                Ping150 = 0.125333,
                Ping160 = 0.1223333,
                Ping170 = 0.15,
                Ping180 = 0.1923111,
                Ping190 = 0.165771,
                Ping200 = 0.1746,
            },
            AntiGroundShots = false, -- doesnt hit ground shots
            UnlockOnDeath = false, -- unlocks on target death
            UnlockOutsideFOV = false, -- unlocks if target outside of fov
            UnlockBehindWall = false, -- unlocks if target behind a wall
        },
        ['Checks'] = {
            VisibleCheck = true, -- wont lock on if player behind a wall
            DeathCheck = true, -- wont lock on if player is knocked or grabbed
            CrewCheck = false, -- wont lock on if player is in your crew
            FriendCheck  = false, -- wont lock on if player is added on roblox
                Distance = { -- wont lock if to far away
                Enabled = false,
                MaxDistance = 250, -- studs
            }
        },
        ['Resolver'] = {
            Enabled = false, -- resolve anti locks and desyncs
            Method = "Delta", -- Delta, Move Direction, No Prediction, Recalculate
            Keybind = false, -- toggles resolver with keybind below
            KeybindBind = "T", -- keybind to toggle resolver if enabled
        },
        ['FOV'] = { -- fov / circle settings
            SilentAim = {
                Visible = true, -- enables fov for silent aim
                Filled = false, -- fills fov
                Size = 25, -- size of fov
                Thickness = 1, -- thickness of fov
                Transparency = 1, -- transparency of fov (0.1 - 1)
                Color = Color3.fromRGB(255,0,0) -- fov color
            },
            Camlock = {
                Visible = false, -- enables fov for silent aim
                Filled = false, -- fills fov
                Size = 30, -- size of fov
                Thickness = 1, -- thickness of fov
                Transparency = 1, -- transparency of fov (0.1 - 1)
                Color = Color3.fromRGB(255,0,0) -- fov color
            },
        },
        ['Airshot'] = {
            Enabled = false, -- adjusts prediction if target is in air (beam niggas down)
            JumpOffset = -1.5, -- changes offset if target is in air
            Smoothness = { -- changes smoothness on target jump
                Enabled = true,
                JumpSmoothness = 0.5, -- smoothness while target is in air
            }
        },
        ['Macro'] = {
            Enabled = true, -- enable macro
            Bind = "X", -- macro bind
            FirstPerson = true, -- macro abuse
        },
        ['CustomCrosshair'] = {
            Enabled = true, -- toggles crosshair
            Mode = "mouse", -- center, mouse
            Visuals = {
                Width = 1.5,
                Length = 10,
                Radius = 11,
                Color = Color3.fromRGB(255,0,0),
            },
            Spin = {
                Enabled = true,
                SpinSpeed = 150,
                SpinMax = 340,
                SpinStyle = Enum.EasingStyle.Circular, -- Circular, Linear
            },
            Resize = {
                Enabled = false,
                ResizeSpeed = 150,
                ResizeMin = 5,
                ResizeMax = 22,
            }
        },
        ['OnHit'] = {
            HitSounds = {
                Enabled = false, -- enables hit sounds
                HitSound = "Rust", -- Bameware, Bubble, Rust, Pick, Sans, Big, Vine, Bruh, Neverlose, Bonk, Skeet, Minecraft
                Volume = 1, -- hit sound volume
            },
            HitLog = {
                Enabled = false, -- notifys you when a target is hit
            }
        },
        ['MemorySpoofer'] = {
            Enabled = false, -- spoofs your memory, scripts increase memory on inject
            Min = 750,
            Max = 1000,
        },
        ['Extra'] = {
            DisableSeats = true, -- disable seats (helps macro and your mental health)
            LowGraphics = false, -- automatically sets low graphics
        },
        ['ESP'] = {
            Enabled = false, -- enables esp, will legit eat your fps like a fat nigga named caseoh
            Boxes = {
                Enabled = false, -- enables boxes
                BoxColor = Color3.fromRGB(0,0,0), -- box color
                Filled = false, -- filles boxes
                FilledBoxColor = Color3.fromRGB(255,255,255), -- box fill color
                HealthBar = false, -- health bar
            },
            Text = {
                Names = false, -- enables names
                Distance = false, -- enables player distances
                TextColor = Color3.fromRGB(255,255,255) -- text color
            },
            Tracer = {
                Enabled = false, -- enables tracers
                TracerOrigin = "Bottom", -- Bottom, Top, Mouse
                TracerColor = Color3.fromRGB(255,0,0),
            }
        }
    }
end

if fraudfun.Startup.Intro then
    local cam = workspace.CurrentCamera
    local x = cam.ViewportSize.X
    local y = cam.ViewportSize.Y
    local newx = math.floor(x * 0.5)
    local newy = math.floor(y * 0.5)

    local SpashScreen = Instance.new("ScreenGui")
    local Image = Instance.new("ImageLabel")
    SpashScreen.Name = "SpashScreen"
    SpashScreen.Parent = game.CoreGui
    SpashScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Image.Name = "Image"
    Image.Parent = SpashScreen
    Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Image.BackgroundTransparency = 1
    Image.Position = UDim2.new(0, newx, 0, newy)
    Image.Size = UDim2.new(0, 1000, 0, 500)
    Image.Image = "rbxassetid://17334881029"
    Image.ImageTransparency = 1
    Image.AnchorPoint = Vector2.new(0.5,0.5)

    local Blur = Instance.new("BlurEffect")
    Blur.Parent = game.Lighting
    Blur.Size = 0
    Blur.Name = math.random(1,123123)


    local function gui(last, sex, t, s, inorout)
        local TI = TweenInfo.new(t or 1, s or Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
        local Tweening = game:GetService("TweenService"):Create(last, TI, sex)
        Tweening:Play()
    end

    gui(Image, {ImageTransparency = 0},0.3)
    gui(Blur, {Size = 20},0.3)
    wait(1.5)
    gui(Image, {ImageTransparency = 1},0.3)
    gui(Blur, {Size = 0},0.3)
    wait(0.3)
end






-- // hi nigga

function UpdateTable()
    getgenv().Evolution = {
        ["Options"] = {
            ["Version"] = "3.1.4-Ro-Exec", -- // Dont touch this is to make sure your using the correct table
            ["Stealth Mode"] = {
                ["Enabled"] = false, -- // Will hide the loader and just load the script 
                ["Key"] = "", -- // Enter your Evolution Key
            },
            ["Internal"] = {
                ["Enabled"] = false, -- // Shows internal ui for evolution
                ["Auto Show"] = false, -- // Will show the ui when you execute
                ["Bind"] = "", -- // Default keybind to toggle ui
            },
            ["FPS Unlocker"] = { -- // Unlocks your fps
                ["Enabled"] = fraudfun.Startup.FPS.UnlockFPS, -- // Will unlock your FPS
                ["FPS"] = fraudfun.Startup.FPS.FpsCap, -- // Maximum FPS
            },
            ["Intro"] = false, -- // Will show a short intro
            ["Stats"] = false, -- // Shows debug stats 
            ["Auto Join Discord"] = false, -- // Will Join Discord
            ["Allow Notifications"] = true, -- // Toggles all notifications
            ["Notifcation Type"] = "xaxa", -- // Akali, Roblox, xaxa
            ["Notifcation Duration"] = 3, -- // How long notifcations will show
        },
        ["Silent Aim"] = {
            ["Enabled"] = fraudfun['Silent Aim'].Enabled, -- // Mouse Redirection
            ["Mode"] = fraudfun['Silent Aim'].Mode, -- // Select mode to select target (FOV, Target )
            ["Target Mode Bind"] = fraudfun['Silent Aim'].TargetBind, -- // Keybind for Target mode
            ["Notify"] = fraudfun['Silent Aim'].TargetNotifications, -- // Sends notifcation when targeting someone
            ["Prediction"] = fraudfun['Silent Aim'].Prediction.Prediction, -- // Prediction Value
            ["Hit Chance"] = fraudfun['Silent Aim'].Prediction.HitChance, -- // Hit chance (1-100)
            ["Target Part"] = fraudfun['Silent Aim'].Hitpart.Hitpart, -- // Any Hitbox (Head, UpperTorso, HumanoidRootPart, LowerTorso)
            ["Target Part Offset"] = 0, -- // Offset if you have the target part to head and you set offset to -1.6 you will hit the torso
            ["Nearest Part To Cursor"] = fraudfun['Silent Aim'].Hitpart.ClosetPart, -- // Sets target part to the nearest body part to your cursor
            ["Closest Point"] = fraudfun['Silent Aim'].Hitpart.ClosetPart, -- // Gets the closest point on the target part (not working rn)
            ["Dot"] = fraudfun['Silent Aim'].Visuals.Dot, -- // Visual 
            ["Line"] = fraudfun['Silent Aim'].Visuals.Tracer, -- // Visual 
            ["Shake"] = {
                ["Enabled"] = false, -- // Will Randomly Offset hit point
                ["X"] = nil, -- // Max X Position
                ["Y"] = nil, -- // Max Y Position
                ["Z"] = nil, -- // Max Z Position
            },
        },
        ["Cam Lock"] = {
            ["Enabled"] = fraudfun.Aimlock.Enabled, -- // Adjust your camera position
            ["Mode"] = fraudfun.Aimlock.Mode, -- // Select mode to select target (FOV, Target_toggle, Target_hold)
            ["Target Mode Bind"] = fraudfun.Aimlock.TargetBind, -- // Keybind for Target modes
            ["Easing Style"] = fraudfun.Aimlock.Prediction.EasingStyle, -- // https://create.roblox.com/docs/reference/engine/enums/EasingStyle
            ["Notify"] = fraudfun.Aimlock.TargetNotifications, -- // Sends notifcation when targeting someone
            ["Prediction"] = fraudfun.Aimlock.Prediction.Prediction, -- // Prediction Value
            ["Target Part"] = fraudfun.Aimlock.Hitpart.Hitpart, -- // Any Hitbox (Head, UpperTorso, HumanoidRootPart, LowerTorso)
            ["Target Part Offset"] = 0, -- // Offset if you have the target part to head and you set offset to -1.6 you will hit the torso
            ["Nearest Part To Cursor"] = fraudfun.Aimlock.Hitpart.ClosetPart,  -- // Sets target part to the nearest body part to your cursor
            ["Closest Point"] = false, -- // Gets the closest point on the target part
            ["Dot"] = fraudfun.Aimlock.Visuals.Dot, -- // Visual 
            ["Line"] = fraudfun.Aimlock.Visuals.Tracer, -- // Visual 
            ["Smoothness"] = {
                ["Enabled"] = fraudfun.Aimlock.Smoothness.Enabled, -- // Prevents snapping when targeting
                ["Value"] = fraudfun.Aimlock.Smoothness.Amount, -- // Smoothness Value
            },
            ["Shake"] = {
                ["Enabled"] = fraudfun.Aimlock.Shake.Enabled, -- // Will Shake your camera randomly when targeting
                ["X"] = fraudfun.Aimlock.Shake.X, -- // Max X Position
                ["Y"] = fraudfun.Aimlock.Shake.Y, -- // Max Y Position
                ["Z"] = fraudfun.Aimlock.Shake.Z, -- // Max Z Position
            },
        },
        ["Global"] = {
            ["Auto Prediction"] = {
                ["Enabled"] = fraudfun.Global.AutoPrediction, -- // Will automatically set your prediction based on your ping
                ["Version"] = "Custom", -- // Default, Old, V2, Custom
                ["Custom Settings"] = { -- // Custom Values
                    ["Ping20"]  = fraudfun.Global.Predictions.Ping30,
                    ["Ping30"]  = fraudfun.Global.Predictions.Ping30,
                    ["Ping40"]  = fraudfun.Global.Predictions.Ping40,
                    ["Ping50"]  = fraudfun.Global.Predictions.Ping50,
                    ["Ping60"]  = fraudfun.Global.Predictions.Ping60,
                    ["Ping70"]  = fraudfun.Global.Predictions.Ping70,
                    ["Ping80"]  = fraudfun.Global.Predictions.Ping80,
                    ["Ping90"]  = fraudfun.Global.Predictions.Ping90,
                    ["Ping100"] = fraudfun.Global.Predictions.Ping100,
                    ["Ping110"] = fraudfun.Global.Predictions.Ping110,
                    ["Ping120"] = fraudfun.Global.Predictions.Ping120,
                    ["Ping130"] = fraudfun.Global.Predictions.Ping130,
                    ["Ping140"] = fraudfun.Global.Predictions.Ping140,
                    ["Ping150"] = fraudfun.Global.Predictions.Ping150,
                    ["Ping160"] = fraudfun.Global.Predictions.Ping160,
                    ["Ping170"] = fraudfun.Global.Predictions.Ping170,
                    ["Ping180"] = fraudfun.Global.Predictions.Ping180,
                    ["Ping190"] = fraudfun.Global.Predictions.Ping190,
                    ["Ping200"] = fraudfun.Global.Predictions.Ping200,
                }
            },
            ["Anti Ground Shots"] = fraudfun.Global.AntiGroundShots, -- // Will prevent you from shooting the ground
            ["Unlock On KO"] = fraudfun.Global.UnlockOnDeath, -- // Unlocks when target dies
            ["Unlock Outside FOV"] = fraudfun.Global.UnlockOutsideFOV, -- // Will unlock when the target leaves your fov
            ["Unlock Behind Wall"] = fraudfun.Global.UnlockBehindWall, -- // Will unlock when the target goes behind a wall
        },
        ["Checks"] = {
            ["Whitelist"] = { -- // Will only lock onto people whitelisted,
                ["Enabled"] = nil,
                ["Usernames"] = {
                    --[[
                        Enter usernames eg: 
                        "Username1",
                        "Username2",
                        "Username3"
                    ]]
                }
            },
            ["Blacklist"] = { -- // Will not lock onto peopled blacklisted,
                ["Enabled"] = nil,
                ["Usernames"] = {
                    --[[
                        Enter usernames eg: 
                        "Username1",
                        "Username2",
                        "Username3"
                    ]]
                }
            },
            ["Visible Check"] = fraudfun.Checks.VisibleCheck, -- // Will check if target is behind a wall
            ["K.O Check"] = fraudfun.Checks.DeathCheck, -- // Will check if target is knocked or grabbed
            ["Crew Check"] = fraudfun.Checks.CrewCheck, -- // Will check if target is in your crew
            ["Friend Check"] = fraudfun.Checks.FriendCheck, -- // Will check if target is your friend if not will not lock
            ["Distance"] = { -- // Not lock onto people if they are too far away
                ["Enabled"] = fraudfun.Checks.Distance.Enabled,
                ["Max Distance"] = fraudfun.Checks.Distance.MaxDistance, -- // Studs
            }
        },
        ["Resolver"] = {
            ["Enabled"] = fraudfun.Resolver.Enabled, -- // Resolve Anti Locks and Desyncs
            ["Method"] = fraudfun.Resolver.Method, -- // Delta, Move Direction, No Prediction, Recalculate
            ["Keybind Enabled"] = fraudfun.Resolver.Keybind, -- // Will toggle resolver when you press key
            ["Keybind"] = fraudfun.Resolver.KeybindBind, -- // Keybind to toggle resolver
        },
        ["FOV"] = { -- // FOV Circle Settings
            ["Silent Aim"] = {
                ["Visible"] = fraudfun.FOV.SilentAim.Visible, -- // Will toggle if you can see the circle
                ["Filled"] = fraudfun.FOV.SilentAim.Filled, -- // Makes circle filled (really fucking ugly)
                ["Size"] = fraudfun.FOV.SilentAim.Size, -- // Size of the circle
                ["Thickness"] = fraudfun.FOV.SilentAim.Thickness, -- // Thickness of the circle
                ["Transparency"] = fraudfun.FOV.SilentAim.Transparency, -- // Transparency of the circle 0.1 - 1
                ["Color"] = fraudfun.FOV.SilentAim.Color -- // Circle Color
            },
            ["Cam Lock"] = {
                ["Visible"] = fraudfun.FOV.Camlock.Visible, -- // Will toggle if you can see the circle
                ["Filled"] = fraudfun.FOV.Camlock.Filled, -- // Makes circle filled (really fucking ugly)
                ["Size"] = fraudfun.FOV.Camlock.Size, -- // Size of the circle
                ["Thickness"] = fraudfun.FOV.Camlock.Thickness, -- // Thickness of the circle
                ["Transparency"] = fraudfun.FOV.Camlock.Transparency, -- // Transparency of the circle 0.1 - 1
                ["Color"] = fraudfun.FOV.Camlock.Color -- // Circle Color
            },
        },
        ["Airshot"] = {
            ["Enabled"] = fraudfun.Airshot.Enabled, -- // Will adjust your prediction if target is in the air
            ["Jump Offset"] = fraudfun.Airshot.JumpOffset, -- // Jump Offset
            ["Cam Lock Smoothness"] = {
                ["Enabled"] = fraudfun.Airshot.Smoothness.Enabled, -- // Will adjust your camlock smoothness if target is in the air
                ["New Smoothness"] = fraudfun.Airshot.Smoothness.JumpSmoothness, -- // Smoothness value
            }
        },
        ["Hit Sound"] = {
            ["Enabled"] = fraudfun.OnHit.HitSounds.Enabled, -- // Sound for when you hit a player
            ["Hit Sound"] = fraudfun.OnHit.HitSounds.HitSound, -- // Minecraft, Bameware, Bubble, Pick, Pop, Rust, Sans, Fart, Big, Vine, Bruh, Skeet, Neverlose, Fatality, Bonk
            ["Volume"] = fraudfun.OnHit.HitSounds.Volume,
        },
        ["Hit Logs"] = {
            ["Enabled"] = fraudfun.OnHit.HitLog.Enabled, -- // Logs when you hit a player
        },
        ["Macro"] = {
            ["Enabled"] = fraudfun.Macro.Enabled, -- // Lua based macro
            ["Bind"] = fraudfun.Macro.Bind, -- // Keybind to start macro
            ["Abuse"] = fraudfun.Macro.FirstPerson, -- // Will use scroll wheel to macro
            ["Speed"] = 1, --// Macro Speed
        },
        ["Spoofer"] = {
            ["Memory"] = {
                ["Enabled"] = fraudfun.MemorySpoofer.Enabled, -- // Will spoof your memory usage
                ["Max"] = fraudfun.MemorySpoofer.Min,
                ["Min"] = fraudfun.MemorySpoofer.Max,
            },
        },
        ["Gun Sorting"] = {
            ["Enabled"] = false, -- // Sorts the guns in your inventory
            ["Bind"] = "Z", -- // Keybind to sort
            ["Delete Extra"] = false, -- // Will destroy any tools that are not sorted (broken)
            ["Slots"] = { -- // You can add up to 9
                "[Double-Barrel SG]",
                "[Revolver]",
                "[TacticalShotgun]",
                "[Shotgun]",
                "[Katana]",
            }
        },
        ["Emotes"] = { -- // Da hood and Hood Modded only (if you have the animation ids for other da hood ripoffs dm xz)
            ["Lay"] = true, ["LayKey"] = Enum.KeyCode.T, -- // Will Play Lay Animation when you press the keybind
            ["Greet"] = true, ["GreetKey"] = Enum.KeyCode.G, -- // Will Play Greet Animation when you press the keybind
            ["Speed"] = false, ["SpeedKey"] = Enum.KeyCode.N, -- // Will Play Speed Animation when you press the keybind
            ["Sturdy"] = false, ["SturdyKey"] = Enum.KeyCode.H, -- // Will Play Sturdy Animation when you press the keybind
            ["Griddy"] = false, ["GriddyKey"] = Enum.KeyCode.G, -- // Will Play Griddy Animation when you press the keybind
        },
        ["Fake Spike"] = {
            ["Enabled"] = false, -- // Will spike your ping to make it look like your lagging
            ["Bind"] = "K", -- // Keybind to spike
            ["Duration"] = 1, -- // How long you will be spiked for
        },
        ["Panic"] = {
            ["Enabled"] = false, -- // Will disable all features
            ["Bind"] = "P", -- // Keybind to panic
            ["Things To Disable"] = {
                ["Options"] = true, -- // Stats, Notifications
                ["Aiming"] = true, -- // Silent Aim, Cam Lock
                ["FOV"] = true, -- // Silent Aim FOV, Cam Lock FOV
                ["Misc"] = true, -- // Macro, Gun Sorting, Fake Spike, Chat Commands
                ["Emotes"] = true, -- // Emotes
            }
        },
        ["Extra"] = {
            ["Disable Seats"] = false, -- // Will disable all the seats that break your macro
            ["Low Graphics"] = false, -- // Will give you low graphics
            ["Mute Boomboxes"] = false, -- // Will mute everyones boombox (FE)
        },
        ["ESP"] = { -- // Allows you to see players through the walls
            ["Enabled"] = false, -- // Main Toggle
            ["Max Distance"] = 500, -- // Maxiumum distance to show esp (studs)
            ["Name"] = { -- // Will show username
                ["Enabled"] = false,
                ["Outline"] = false,
                ["Color"] = Color3.fromRGB(255, 255, 255)
            },
            ["Box"] = { -- // Will show a box around character
                ["Enabled"] = false,
                ["Outline"] = false,
                ["Color"] = Color3.fromRGB(255, 255, 255)
            },
            ["Health Bar"] = { -- // Will show a health bar next to box
                ["Enabled"] = false,
                ["Outline"] = false,
                ["Color"] = Color3.fromRGB(0, 255, 0)
            },
            ["Distance"] = { -- // Will tell you the distance (in studs)
                ["Enabled"] = false,
                ["Outline"] = false,
                ["Color"] = Color3.fromRGB(255, 255, 255)
            },
        },
        ["Chat Commands"] = {
            ["Enabled"] = true,
            ["Prefix"] = ".",
            ["Commands"] = { -- // CANNOT HAVE SPACES!!!
                ["Prediction"] = "pred", -- // ex; $pred 0.115
                ["ToggleFOV"] = "draw", -- // ex; $draw true (you can also do "on" or "yes" and to disable you do "off" or "yes" or "false")
                ["SizeFOV"] = "radius", -- // ex; $radius 100
                ["GotoLocation"] = "tp", -- // ex; $tp bank (locations in server)
                ["ToggleResolver"] = "resolver", -- // ex; $resolver true (you can also do "on" or "yes" and to disable you do "off" or "yes" or "false")
                ["JoinDiscord"] = "discord", -- // ex; $discord
                ["RejoinServer"] = "rj", -- // ex; $rj
                ["ToggleSilentAim"] = "silent", -- // ex; $silent true (you can also do "on" or "yes" and to disable you do "off" or "yes" or "false")
                ["ToggleCamLock"] = "camlock", -- // ex; $camlock true (you can also do "on" or "yes" and to disable you do "off" or "yes" or "false")
                ["CamLockSmoothness"] = "smoothness", -- // ex; $smoothness 0.086
                ["CheckForExploiters"] = "check", -- // ex; $check
                ["ForceReset"] = "reset", -- // ex; $reset
            }
        }
    }
end



game:GetService("RunService").Heartbeat:Connect(function()
    UpdateTable()
    if fraudfun.Aimlock.Mode == "Target" then
        Evolution['Cam Lock']['Mode'] = "Target_toggle"
    end
end)

local smoothplastic = Enum.Material.SmoothPlastic
local objects = {}

local function scan(object)
    local objectlist = object:GetChildren()
    for i = 1, #objectlist do
        if objectlist[i]:IsA('BasePart') then
            objects[objectlist[i]] = objectlist[i].Material
        end
        scan(objectlist[i])
    end
end

scan(workspace)


local utility = {
    Invite = "fraudlol",
    Folder = "fraudlol",
    Version = "3.1.4-Ro-Exec",
    Ping = 5,
    Bypass = {
        12927359803, -- Dah Aim Trainer
        12867571492, -- KatanaHood
        11867820563, -- Dae Hood
        12618586930, -- Dat Hood
        13018411607, -- Dat Hood 2
        13018411607, -- // Dat Hood Backup
        9633073067, -- // Del Hood
        11956541652, --// Dav Hood
        10100958808, -- // Da Downhill
        12815368779, -- // Da Hood Aim Trainer
        13126185789, -- // Da Hood Aim Trainer VC
    }
}

if not LPH_OBFUSCATED and not LPH_JIT_ULTRA then
    LPH_NO_VIRTUALIZE = function(f) return f end
end

-- yes i know its endless ui and crosshair 
LPH_NO_VIRTUALIZE(function()
    function crosshairupd()
    getgenv().crosshair = {
        enabled = fraudfun.CustomCrosshair.Enabled,
        refreshrate = 0,
        mode = fraudfun.CustomCrosshair.Mode, -- center, mouse, custom
        position = Vector2.new(0,0), -- custom position
    
        width = fraudfun.CustomCrosshair.Visuals.Width,
        length = fraudfun.CustomCrosshair.Visuals.Length,
        radius = fraudfun.CustomCrosshair.Visuals.Radius,
        color = fraudfun.CustomCrosshair.Visuals.Color,
    
        spin = fraudfun.CustomCrosshair.Spin.Enabled, -- animate the rotation
        spin_speed = fraudfun.CustomCrosshair.Spin.SpinSpeed,
        spin_max = fraudfun.CustomCrosshair.Spin.SpinMax,
        spin_style = fraudfun.CustomCrosshair.Spin.SpinStyle, -- Linear for normal smooth spin
    
        resize = fraudfun.CustomCrosshair.Resize.Enabled, -- animate the length
        resize_speed = fraudfun.CustomCrosshair.Resize.ResizeSpeed,
        resize_min = fraudfun.CustomCrosshair.Resize.ResizeMin,
        resize_max = fraudfun.CustomCrosshair.Resize.ResizeMax,
    
    }
    end
    
    game:GetService("RunService").Heartbeat:Connect(function()
        crosshairupd()
    end)
    
    local old; old = hookfunction(Drawing.new, function(class, properties)
        local drawing = old(class)
        for i,v in next, properties or {} do
            drawing[i] = v
        end
        return drawing
    end)
    
    local runservice = game:GetService('RunService')
    local inputservice = game:GetService('UserInputService')
    local tweenservice = game:GetService('TweenService')
    local camera = workspace.CurrentCamera
    
    local last_render = 0
    
    local drawings = {
        crosshair = {},
        text = {
            Drawing.new('Text', {Size = 14.2, Font = 2, Outline = true, Text = 'fraud', Color = Color3.new(1,1,1)}),
            Drawing.new('Text', {Size = 14.2, Font = 2, Outline = true, Text = ".lol"}),
        
        }
    }
    
    for idx = 1, 4 do
        drawings.crosshair[idx] = Drawing.new('Line')
        drawings.crosshair[idx + 4] = Drawing.new('Line')
    end
    
    function solve(angle, radius)
        return Vector2.new(
            math.sin(math.rad(angle)) * radius,
            math.cos(math.rad(angle)) * radius
        )
    end
    
    runservice.PostSimulation:Connect(function()
    
        local _tick = tick()
    
        if _tick - last_render > crosshair.refreshrate then
            last_render = _tick
    
            local position = (
                crosshair.mode == 'center' and camera.ViewportSize / 2 or
                crosshair.mode == 'mouse' and inputservice:GetMouseLocation() or
                crosshair.position
            )
    
            local text_1 = drawings.text[1]
            local text_2 = drawings.text[2]
    
            text_1.Visible = crosshair.enabled
            text_2.Visible = crosshair.enabled
    
            if crosshair.enabled then
    
                local text_x = text_1.TextBounds.X + text_2.TextBounds.X
    
                text_1.Position = position + Vector2.new(-text_x / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 15)
                text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X)
                text_2.Color = crosshair.color
                
                for idx = 1, 4 do
                    local outline = drawings.crosshair[idx]
                    local inline = drawings.crosshair[idx + 4]
        
                    local angle = (idx - 1) * 90
                    local length = crosshair.length
        
                    if crosshair.spin then
                        local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                        angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360
                    end
        
                    if crosshair.resize then
                        local resize_length = tick() * crosshair.resize_speed % 180
                        length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                    end
        
                    inline.Visible = true
                    inline.Color = crosshair.color
                    inline.From = position + solve(angle, crosshair.radius)
                    inline.To = position + solve(angle, crosshair.radius + length)
                    inline.Thickness = crosshair.width
        
                    outline.Visible = true
                    outline.From = position + solve(angle, crosshair.radius - 1)
                    outline.To = position + solve(angle, crosshair.radius + length + 1)
                    outline.Thickness = crosshair.width + 1.5    
                end
            else
                for idx = 1, 4 do
                    drawings.crosshair[idx].Visible = false
                    drawings.crosshair[idx + 4].Visible = false
                end
            end
    
        end
    end)
    
    local espLib = {
        drawings = {},
        instances = {},
        espCache = {},
        chamsCache = {},
        objectCache = {},
        conns = {},
        whitelist = {}, -- insert string that is the player's name you want to whitelist (turns esp color to whitelistColor in options)
        blacklist = {}, -- insert string that is the player's name you want to blacklist (removes player from esp)
        options = {
            enabled = true,
            minScaleFactorX = 1,
            maxScaleFactorX = 10,
            minScaleFactorY = 1,
            maxScaleFactorY = 10,
            boundingBox = false, -- WARNING | Significant Performance Decrease when true
            boundingBoxDescending = false,
            font = 2,
            fontSize = 13,
            limitDistance = false,
            maxDistance = 1000,
            visibleOnly = false,
            teamCheck = false,
            teamColor = false,
            fillColor = nil,
            whitelistColor = Color3.new(185, 38, 102),
            outOfViewArrows = false,
            outOfViewArrowsFilled = false,
            outOfViewArrowsSize = 25,
            outOfViewArrowsRadius = 100,
            outOfViewArrowsColor = Color3.new(1, 1, 1),
            outOfViewArrowsTransparency = 0.5,
            outOfViewArrowsOutline = false,
            outOfViewArrowsOutlineFilled = false,
            outOfViewArrowsOutlineColor = Color3.new(1, 1, 1),
            outOfViewArrowsOutlineTransparency = 1,
            names = false,
            nameTransparency = 1,
            nameColor = Color3.new(1, 1, 1),
            boxes = false,
            boxesTransparency = 1,
            boxesColor = Color3.new(185, 38, 102),
            boxFill = false,
            boxFillTransparency = 0.5,
            boxFillColor = Color3.new(185, 38, 102),
            healthBars = false,
            healthBarsSize = 1,
            healthBarsTransparency = 1,
            healthBarsColor = Color3.new(0, 1, 0),
            healthText = false,
            healthTextTransparency = 1,
            healthTextSuffix = "%",
            healthTextColor = Color3.new(1, 1, 1),
            distance = false,
            distanceTransparency = 1,
            distanceSuffix = " Studs",
            distanceColor = Color3.new(1, 1, 1),
            tracers = false,
            tracerTransparency = 1,
            tracerColor = Color3.new(1, 1, 1),
            tracerOrigin = "Bottom", -- Available [Mouse, Top, Bottom]
            chams = false,
            chamsFillColor = Color3.new(185, 38, 102),
            chamsFillTransparency = 0.5,
            chamsOutlineColor = Color3.new(),
            chamsOutlineTransparency = 0
        },
     };
     local espLib = loadstring(game:HttpGet(('https://blazed.lol/modules/esp.lua'),true))()
    
    if fraudfun.ESP.Enabled then
    espLib:Load()
    game:GetService("RunService").Heartbeat:Connect(function()
    espLib.options.enabled = fraudfun.ESP.Enabled
    espLib.options.boxes = fraudfun.ESP.Boxes.Enabled
    espLib.options.boxesColor = fraudfun.ESP.Boxes.BoxColor
    espLib.options.boxFill = fraudfun.ESP.Boxes.Filled
    espLib.options.boxFillColor = fraudfun.ESP.Boxes.FilledBoxColor
    espLib.options.healthBars = fraudfun.ESP.Boxes.HealthBar
    
    espLib.options.names = fraudfun.ESP.Text.Names
    espLib.options.distance = fraudfun.ESP.Text.Distance
    espLib.options.nameColor = fraudfun.ESP.Text.TextColor
    
    espLib.options.tracers = fraudfun.ESP.Tracer.Enabled
    espLib.options.tracerColor = fraudfun.ESP.Tracer.TracerColor
    espLib.options.tracerOrigin = fraudfun.ESP.Tracer.TracerOrigin
    end)
    end
    
    -- // make multiselect in order
    -- // add border pixel math to dragging
    -- // containers canvasscroll update on setvisible
    -- // Dragging sys has errors
    -- // I think something was wrong with the keybinds/indicators tweening
    -- // Menu Effects (OnHover, OnClick)
    
    local Settings = {
        Accent = Color3.fromHex("#880808"),
        Font = Enum.Font.SourceSans,
        IsBackgroundTransparent = true,
        Rounded = false,
        Dim = false,
        
        ItemColor = Color3.fromRGB(30, 30, 30),
        BorderColor = Color3.fromRGB(45, 45, 45),
        MinSize = Vector2.new(500, 400),
        MaxSize = Vector2.new(700, 600)
    }
    
    if fraudfun.Startup.GUI then
    local Menu = {}
    local Tabs = {}
    local Items = {}
    local EventObjects = {} -- For updating items on menu property change
    local Notifications = {}
    
    local Scaling = {True = false, Origin = nil, Size = nil}
    local Dragging = {Gui = nil, True = false}
    local Draggables = {}
    local ToolTip = {Enabled = false, Content = "", Item = nil}
    
    local HotkeyRemoveKey = Enum.KeyCode.RightControl
    local Selected = {
        Frame = nil,
        Item = nil,
        Offset = UDim2.new(),
        Follow = false
    }
    local SelectedTab
    local SelectedTabLines = {}
    
    
    local wait = task.wait
    local delay = task.delay
    local spawn = task.spawn
    local protect_gui = function(Gui, Parent)
        if gethui and syn and syn.protect_gui then 
            Gui.Parent = gethui() 
        elseif not gethui and syn and syn.protect_gui then 
            syn.protect_gui(Gui)
            Gui.Parent = Parent 
        else 
            Gui.Parent = Parent 
        end
    end
    
    local CoreGui = game:GetService("CoreGui")
    local UserInput = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local TextService = game:GetService("TextService")
    local TweenService = game:GetService("TweenService")
    
    
    local __Menu = {}
    setmetatable(Menu, {
        __index = function(self, Key) return __Menu[Key] end,
        __newindex = function(self, Key, Value)
            __Menu[Key] = Value
            
            if Key == "Hue" or Key == "ScreenSize" then return end
    
            for _, Object in pairs(EventObjects) do Object:Update() end
            for _, Notification in pairs(Notifications) do Notification:Update() end
        end
    })
    
    
    Menu.Accent = Settings.Accent
    Menu.Font = Settings.Font
    Menu.IsBackgroundTransparent = Settings.IsBackgroundTransparent
    Menu.Rounded = Settings.IsRounded
    Menu.Dim = Settings.IsDim
    Menu.ItemColor = Settings.ItemColor
    Menu.BorderColor = Settings.BorderColor
    Menu.MinSize = Settings.MinSize
    Menu.MaxSize = Settings.MaxSize
    
    Menu.Hue = 0
    Menu.IsVisible = false
    Menu.ScreenSize = Vector2.new()
    
    
    local function AddEventListener(self: GuiObject, Update: any)
        table.insert(EventObjects, {
            self = self,
            Update = Update
        })
    end
    
    
    local function CreateCorner(Parent: Instance, Pixels: number): UICorner
        local UICorner = Instance.new("UICorner")
        UICorner.Name = "Corner"
        UICorner.Parent = Parent
        return UICorner
    end
    
    
    local function CreateStroke(Parent: Instance, Color: Color3, Thickness: number, Transparency: number): UIStroke
        local UIStroke = Instance.new("UIStroke")
        UIStroke.Name = "Stroke"
        UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
        UIStroke.Color = Color or Color3.new()
        UIStroke.Thickness = Thickness or 1
        UIStroke.Transparency = Transparency or 0
        UIStroke.Enabled = true
        UIStroke.Parent = Parent
        return UIStroke
    end 
    
    
    local function CreateLine(Parent: Instance, Size: UDim2, Position: UDim2, Color: Color3): Frame
        local Line = Instance.new("Frame")
        Line.Name = "Line"
        Line.BackgroundColor3 = typeof(Color) == "Color3" and Color or Menu.Accent
        Line.BorderSizePixel = 0
        Line.Size = Size or UDim2.new(1, 0, 0, 1)
        Line.Position = Position or UDim2.new()
        Line.Parent = Parent
    
        if Line.BackgroundColor3 == Menu.Accent then
            AddEventListener(Line, function() Line.BackgroundColor3 = Menu.Accent end)
        end
    
        return Line
    end
    
    
    local function CreateLabel(Parent: Instance, Name: string, Text: string, Size: UDim2, Position: UDim2): TextLabel
        local Label = Instance.new("TextLabel")
        Label.Name = Name
        Label.BackgroundTransparency = 1
        Label.Size = Size or UDim2.new(1, 0, 0, 15)
        Label.Position = Position or UDim2.new()
        Label.Font = Enum.Font.SourceSans
        Label.Text = Text or ""
        Label.TextColor3 = Color3.new(1, 1, 1)
        Label.TextSize = 14
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Parent = Parent
        return Label
    end
    
    
    local function UpdateSelected(Frame: Instance, Item: Item, Offset: UDim2)
        local Selected_Frame = Selected.Frame
        if Selected_Frame then
            Selected_Frame.Visible = false
            Selected_Frame.Parent = nil
        end
    
        Selected = {}
    
        if Frame then
            if Selected_Frame == Frame then return end
            Selected = {
                Frame = Frame,
                Item = Item,
                Offset = Offset
            }
    
            Frame.ZIndex = 3
            Frame.Visible = true
            Frame.Parent = Menu.Screen
        end
    end
    
    
    local function SetDraggable(self: GuiObject)
        table.insert(Draggables, self)
        local DragOrigin
        local GuiOrigin
    
        self.InputBegan:Connect(function(Input: InputObject, Process: boolean)
            if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                for _, v in ipairs(Draggables) do
                    v.ZIndex = 1
                end
                self.ZIndex = 2
    
                Dragging = {Gui = self, True = true}
                DragOrigin = Vector2.new(Input.Position.X, Input.Position.Y)
                GuiOrigin = self.Position
            end
        end)
    
        UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
            if Dragging.Gui ~= self then return end
            if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
                Dragging = {Gui = nil, True = false}
                return
            end
            if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
                local Delta = Vector2.new(Input.Position.X, Input.Position.Y) - DragOrigin
                local ScreenSize = Menu.ScreenSize
    
                local ScaleX = (ScreenSize.X * GuiOrigin.X.Scale)
                local ScaleY = (ScreenSize.Y * GuiOrigin.Y.Scale)
                local OffsetX = math.clamp(GuiOrigin.X.Offset + Delta.X + ScaleX,   0, ScreenSize.X - self.AbsoluteSize.X)
                local OffsetY = math.clamp(GuiOrigin.Y.Offset + Delta.Y + ScaleY, -36, ScreenSize.Y - self.AbsoluteSize.Y)
                
                local Position = UDim2.fromOffset(OffsetX, OffsetY)
                self.Position = Position
            end
        end)
    end
    
    
    Menu.Screen = Instance.new("ScreenGui")
    Menu.Screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    protect_gui(Menu.Screen, CoreGui)
    Menu.ScreenSize = Menu.Screen.AbsoluteSize
    
    local Menu_Frame = Instance.new("Frame")
    local MenuScaler_Button = Instance.new("TextButton")
    local Title_Label = Instance.new("TextLabel")
    local Icon_Image = Instance.new("ImageLabel")
    local TabHandler_Frame = Instance.new("Frame")
    local TabIndex_Frame = Instance.new("Frame")
    local Tabs_Frame = Instance.new("Frame")
    
    local Notifications_Frame = Instance.new("Frame")
    local MenuDim_Frame = Instance.new("Frame")
    local ToolTip_Label = Instance.new("TextLabel")
    local Modal = Instance.new("TextButton")
    
    Menu_Frame.Name = "Menu"
    Menu_Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    Menu_Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    Menu_Frame.BorderMode = Enum.BorderMode.Inset
    Menu_Frame.Position = UDim2.new(0.5, -250, 0.5, -275)
    Menu_Frame.Size = UDim2.new(0, 500, 0, 550)
    Menu_Frame.Visible = false
    Menu_Frame.Parent = Menu.Screen
    CreateStroke(Menu_Frame, Color3.new(), 2)
    CreateLine(Menu_Frame, UDim2.new(1, -8, 0, 1), UDim2.new(0, 4, 0, 15))
    SetDraggable(Menu_Frame)
    
    MenuScaler_Button.Name = "MenuScaler"
    MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    MenuScaler_Button.BorderColor3 = Color3.fromRGB(40, 40, 40)
    MenuScaler_Button.BorderSizePixel = 0
    MenuScaler_Button.Position = UDim2.new(1, -15, 1, -15)
    MenuScaler_Button.Size = UDim2.fromOffset(15, 15)
    MenuScaler_Button.Font = Enum.Font.SourceSans
    MenuScaler_Button.Text = ""
    MenuScaler_Button.TextColor3 = Color3.new(1, 1, 1)
    MenuScaler_Button.TextSize = 14
    MenuScaler_Button.AutoButtonColor = false
    MenuScaler_Button.Parent = Menu_Frame
    MenuScaler_Button.InputBegan:Connect(function(Input, Process)
        if Process then return end
        if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            UpdateSelected()
            Scaling = {
                True = true,
                Origin = Vector2.new(Input.Position.X, Input.Position.Y),
                Size = Menu_Frame.AbsoluteSize - Vector2.new(0, 36)
            }
        end
    end)
    MenuScaler_Button.InputEnded:Connect(function(Input, Process)
        if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            UpdateSelected()
            Scaling = {
                True = false,
                Origin = nil,
                Size = nil
            }
        end
    end)
    
    Icon_Image.Name = "Icon"
    Icon_Image.BackgroundTransparency = 1
    Icon_Image.Position = UDim2.new(0, 5, 0, 0)
    Icon_Image.Size = UDim2.fromOffset(15, 15)
    Icon_Image.Image = "rbxassetid://0"
    Icon_Image.Visible = false
    Icon_Image.Parent = Menu_Frame
    
    Title_Label.Name = "Title"
    Title_Label.BackgroundTransparency = 1
    Title_Label.Position = UDim2.new(0, 5, 0, 0)
    Title_Label.Size = UDim2.new(1, -10, 0, 15)
    Title_Label.Font = Enum.Font.SourceSans
    Title_Label.Text = ""
    Title_Label.TextColor3 = Color3.new(1, 1, 1)
    Title_Label.TextSize = 14
    Title_Label.TextXAlignment = Enum.TextXAlignment.Left
    Title_Label.RichText = true
    Title_Label.Parent = Menu_Frame
    
    TabHandler_Frame.Name = "TabHandler"
    TabHandler_Frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    TabHandler_Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    TabHandler_Frame.BorderMode = Enum.BorderMode.Inset
    TabHandler_Frame.Position = UDim2.new(0, 4, 0, 19)
    TabHandler_Frame.Size = UDim2.new(1, -8, 1, -25)
    TabHandler_Frame.Parent = Menu_Frame
    CreateStroke(TabHandler_Frame, Color3.new(), 2)
    
    TabIndex_Frame.Name = "TabIndex"
    TabIndex_Frame.BackgroundTransparency = 1
    TabIndex_Frame.Position = UDim2.new(0, 1, 0, 1)
    TabIndex_Frame.Size = UDim2.new(1, -2, 0, 20)
    TabIndex_Frame.Parent = TabHandler_Frame
    
    Tabs_Frame.Name = "Tabs"
    Tabs_Frame.BackgroundTransparency = 1
    Tabs_Frame.Position = UDim2.new(0, 1, 0, 26)
    Tabs_Frame.Size = UDim2.new(1, -2, 1, -25)
    Tabs_Frame.Parent = TabHandler_Frame
    
    Notifications_Frame.Name = "Notifications"
    Notifications_Frame.BackgroundTransparency = 1
    Notifications_Frame.Size = UDim2.new(1, 0, 1, 36)
    Notifications_Frame.Position = UDim2.fromOffset(0, -36)
    Notifications_Frame.ZIndex = 5
    Notifications_Frame.Parent = Menu.Screen
    
    ToolTip_Label.Name = "ToolTip"
    ToolTip_Label.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    ToolTip_Label.BorderColor3 = Menu.BorderColor
    ToolTip_Label.BorderMode = Enum.BorderMode.Inset
    ToolTip_Label.AutomaticSize = Enum.AutomaticSize.XY
    ToolTip_Label.Size = UDim2.fromOffset(0, 0, 0, 15)
    ToolTip_Label.Text = ""
    ToolTip_Label.TextSize = 14
    ToolTip_Label.Font = Enum.Font.SourceSans
    ToolTip_Label.TextColor3 = Color3.new(1, 1, 1)
    ToolTip_Label.ZIndex = 5
    ToolTip_Label.Visible = false
    ToolTip_Label.Parent = Menu.Screen
    CreateStroke(ToolTip_Label, Color3.new(), 1)
    AddEventListener(ToolTip_Label, function()
        ToolTip_Label.BorderColor3 = Menu.BorderColor
    end)
    
    Modal.Name = "Modal"
    Modal.BackgroundTransparency = 1
    Modal.Modal = true
    Modal.Text = ""
    Modal.Parent = Menu_Frame
    
    
    --SelectedTabLines.Top = CreateLine(nil, UDim2.new(1, 0, 0, 1), UDim2.new())
    SelectedTabLines.Left = CreateLine(nil, UDim2.new(0, 1, 1, 0), UDim2.new(), Color3.new())
    SelectedTabLines.Right = CreateLine(nil, UDim2.new(0, 1, 1, 0), UDim2.new(1, -1, 0, 0), Color3.new())
    SelectedTabLines.Bottom = CreateLine(TabIndex_Frame, UDim2.new(), UDim2.new(0, 0, 1, 0), Color3.new())
    SelectedTabLines.Bottom2 = CreateLine(TabIndex_Frame, UDim2.new(), UDim2.new(), Color3.new())
    
    
    local function GetDictionaryLength(Dictionary: table)
        local Length = 0
        for _ in pairs(Dictionary) do
            Length += 1
        end
        return Length
    end
    
    
    local function UpdateSelectedTabLines(Tab: Tab)
        if not Tab then return end
    
        if (Tab.Button.AbsolutePosition.X > Tab.self.AbsolutePosition.X) then
            SelectedTabLines.Left.Visible = true
        else
            SelectedTabLines.Left.Visible = false
        end
    
        if (Tab.Button.AbsolutePosition.X + Tab.Button.AbsoluteSize.X < Tab.self.AbsolutePosition.X + Tab.self.AbsoluteSize.X) then
            SelectedTabLines.Right.Visible = true
        else
            SelectedTabLines.Right.Visible = false
        end
    
        --SelectedTabLines.Top.Parent = Tab.Button
        SelectedTabLines.Left.Parent = Tab.Button
        SelectedTabLines.Right.Parent = Tab.Button
    
        local FRAME_POSITION = Tab.self.AbsolutePosition
        local BUTTON_POSITION = Tab.Button.AbsolutePosition
        local BUTTON_SIZE = Tab.Button.AbsoluteSize
        local LENGTH = BUTTON_POSITION.X - FRAME_POSITION.X
        local OFFSET = (BUTTON_POSITION.X + BUTTON_SIZE.X) - FRAME_POSITION.X
    
        SelectedTabLines.Bottom.Size = UDim2.new(0, LENGTH + 1, 0, 1)
        SelectedTabLines.Bottom2.Size = UDim2.new(1, -OFFSET, 0, 1)
        SelectedTabLines.Bottom2.Position = UDim2.new(0, OFFSET, 1, 0)
    end
    
    
    local function UpdateTabs()
        for _, Tab in pairs(Tabs) do
            Tab.Button.Size = UDim2.new(1 / GetDictionaryLength(Tabs), 0, 1, 0)
            Tab.Button.Position = UDim2.new((1 / GetDictionaryLength(Tabs)) * (Tab.Index - 1), 0, 0, 0)
        end
        UpdateSelectedTabLines(SelectedTab)
    end
    
    
    local function GetTab(Tab_Name: string): Tab
        assert(Tab_Name, "NO TAB_NAME GIVEN")
        return Tabs[Tab_Name]
    end
    
    local function ChangeTab(Tab_Name: string)
        assert(Tabs[Tab_Name], "Tab \"" .. tostring(Tab_Name) .. "\" does not exist!")
        for _, Tab in pairs(Tabs) do
            Tab.self.Visible = false
            Tab.Button.BackgroundColor3 = Menu.ItemColor
            Tab.Button.TextColor3 = Color3.fromRGB(205, 205, 205)
        end
        local Tab = GetTab(Tab_Name)
        Tab.self.Visible = true
        Tab.Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Tab.Button.TextColor3 = Color3.new(1, 1, 1)
    
        SelectedTab = Tab
        UpdateSelected()
        UpdateSelectedTabLines(Tab)
    end
    
    
    local function GetContainer(Tab_Name: string, Container_Name: string): Container
        assert(Tab_Name, "NO TAB_NAME GIVEN")
        assert(Container_Name, "NO CONTAINER NAME GIVEN")
        return GetTab(Tab_Name)[Container_Name]
    end
    
    
    local function CheckItemIndex(Item_Index: number, Method: string)
        assert(typeof(Item_Index) == "number", "invalid argument #1 to '" .. Method .. "' (number expected, got " .. typeof(Item_Index) .. ")")
        assert(Item_Index <= #Items and Item_Index > 0, "invalid argument #1 to '" .. Method .. "' (index out of range")
    end
    
    
    function Menu:GetItem(Index: number): Item
        CheckItemIndex(Index, "GetItem")
        return Items[Index]
    end
    
    
    function Menu:FindItem(Tab_Name: string, Container_Name: string, Class_Name: string, Name: string): Item
        local Result
        for Index, Item in ipairs(Items) do
            if Item.Tab == Tab_Name and Item.Container == Container_Name then
                if Item.Name == Name and (Item.Class == Class_Name) then
                    Result = Index
                    break
                end
            end
        end
    
        if Result then
            return Menu:GetItem(Result)
        else
            return error("Item " .. tostring(Name) .. " was not found")
        end
    end
    
    
    function Menu:SetTitle(Name: string)
        Title_Label.Text = tostring(Name)
    end
    
    
    function Menu:SetIcon(Icon: string)
        if typeof(Icon) == "string" or typeof(Icon) == "number" then
            Title_Label.Position = UDim2.fromOffset(20, 0)
            Title_Label.Size = UDim2.new(1, -40, 0, 15)
            Icon_Image.Image = "rbxassetid://" .. string.gsub(tostring(Icon), "rbxassetid://", "")
            Icon_Image.Visible = true
        else
            Title_Label.Position = UDim2.fromOffset(5, 0)
            Title_Label.Size = UDim2.new(1, -10, 0, 15)
            Icon_Image.Image = ""
            Icon_Image.Visible = false
        end
    end
    
    
    function Menu:SetSize(Size: Vector2)
        local Size = typeof(Size) == "Vector2" and Size or typeof(Size) == "UDim2" and Vector2.new(Size.X, Size.Y) or Menu.MinSize
        local X = Size.X
        local Y = Size.Y
    
        if (X > Menu.MinSize.X and X < Menu.MaxSize.X) then
            X = math.clamp(X, Menu.MinSize.X, Menu.MaxSize.X)
        end
        if (Y > Menu.MinSize.Y and Y < Menu.MaxSize.Y) then
            Y = math.clamp(Y, Menu.MinSize.Y, Menu.MaxSize.Y)
        end
    
        Menu_Frame.Size = UDim2.fromOffset(X, Y)
        UpdateTabs()
    end
    
    
    function Menu:SetVisible(Visible: boolean)
        local IsVisible = typeof(Visible) == "boolean" and Visible
        Menu_Frame.Visible = IsVisible
        Menu.IsVisible = IsVisible
        if IsVisible == false then
            UpdateSelected()
        end
    end
    
    
    function Menu:SetTab(Tab_Name: string)
        ChangeTab(Tab_Name)
    end
    
    
    -- this function should be private
    function Menu:SetToolTip(Enabled: boolean, Content: string, Item: Instance)
        ToolTip = {
            Enabled = Enabled,
            Content = Content,
            Item = Item
        }
    
        ToolTip_Label.Visible = Enabled
    end
    
    
    function Menu.Line(Parent: Instance, Size: UDim2, Position: UDim2): Line
        local Line = {self = CreateLine(Parent, Size, Position)}
        Line.Class = "Line"
        return Line
    end
    
    
    function Menu.Tab(Tab_Name: string): Tab
        assert(Tab_Name and typeof(Tab_Name) == "string", "TAB_NAME REQUIRED")
        if Tabs[Tab_Name] then return error("TAB_NAME '" .. tostring(Tab_Name) .. "' ALREADY EXISTS") end
        local Frame = Instance.new("Frame")
        local Button = Instance.new("TextButton")
    
        local Tab = {self = Frame, Button = Button}
        Tab.Class = "Tab"
        Tab.Index = GetDictionaryLength(Tabs) + 1
    
    
        local function CreateSide(Side: string)
            local Frame = Instance.new("ScrollingFrame")
            local ListLayout = Instance.new("UIListLayout")
    
            Frame.Name = Side
            Frame.Active = true
            Frame.BackgroundTransparency = 1
            Frame.BorderSizePixel = 0
            Frame.Size = Side == "Middle" and UDim2.new(1, -10, 1, -10) or UDim2.new(0.5, -10, 1, -10)
            Frame.Position = (Side == "Left" and UDim2.fromOffset(5, 5)) or (Side == "Right" and UDim2.new(0.5, 5, 0, 5) or Side == "Middle" and UDim2.fromOffset(5, 5))
            Frame.CanvasSize = UDim2.new(0, 0, 0, -10)
            Frame.ScrollBarThickness = 2
            Frame.ScrollBarImageColor3 = Menu.Accent
            Frame.Parent = Tab.self
            AddEventListener(Frame, function()
                Frame.ScrollBarImageColor3 = Menu.Accent
            end)
            Frame:GetPropertyChangedSignal("CanvasPosition"):Connect(UpdateSelected)
    
            ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            ListLayout.Padding = UDim.new(0, 10)
            ListLayout.Parent = Frame
        end
    
    
        Button.Name = "Button"
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderSizePixel = 0
        Button.Font = Enum.Font.SourceSans
        Button.Text = Tab_Name
        Button.TextColor3 = Color3.fromRGB(205, 205, 205)
        Button.TextSize = 14
        Button.Parent = TabIndex_Frame
        AddEventListener(Button, function()
            if Button.TextColor3 == Color3.fromRGB(205, 205, 205) then
                Button.BackgroundColor3 = Menu.ItemColor
            end
            Button.BackgroundColor3 = Menu.ItemColor
            Button.BorderColor3 = Menu.BorderColor
        end)
        Button.MouseButton1Click:Connect(function()
            ChangeTab(Tab_Name)
        end)
        
        Frame.Name = Tab_Name .. "Tab"
        Frame.BackgroundTransparency = 1
        Frame.Size = UDim2.new(1, 0, 1, 0)
        Frame.Visible = false
        Frame.Parent = Tabs_Frame
    
        CreateSide("Middle")
        CreateSide("Left")
        CreateSide("Right")
    
        Tabs[Tab_Name] = Tab
    
        ChangeTab(Tab_Name)
        UpdateTabs()
        return Tab
    end
    
    
    function Menu.Container(Tab_Name: string, Container_Name: string, Side: string): Container
        local Tab = GetTab(Tab_Name)
        assert(typeof(Tab_Name) == "string", "TAB_NAME REQUIRED")
        if Tab[Container_Name] then return error("CONTAINER_NAME '" .. tostring(Container_Name) .. "' ALREADY EXISTS") end
        local Side = Side or "Left"
    
        local Frame = Instance.new("Frame")
        local Label = CreateLabel(Frame, "Title", Container_Name, UDim2.fromOffset(206, 15),  UDim2.fromOffset(5, 0))
        local Line = CreateLine(Frame, UDim2.new(1, -10, 0, 1), UDim2.fromOffset(5, 15))
    
        local Container = {self = Frame, Height = 0}
        Container.Class = "Container"
        Container.Visible = true
    
        function Container:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function Container:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if self.Visible == Visible then return end
            
            Frame.Visible = Visible
            self.Visible = Visible
            self:UpdateSize(Visible and 25 or -25, Frame)
        end
    
        function Container:UpdateSize(Height: float, Item: GuiObject)
            self.Height += Height
            Frame.Size += UDim2.fromOffset(0, Height)
            Tab.self[Side].CanvasSize += UDim2.fromOffset(0, Height)
    
            if Item then
                local ItemY = Item.AbsolutePosition.Y
                if math.sign(Height) == 1 then
                    ItemY -= 1
                end
    
                for _, item in ipairs(Frame:GetChildren()) do
                    if (item == Label or item == Line or item == Stroke or Item == item) then continue end -- exlude these
                    local item_y = item.AbsolutePosition.Y
                    if item_y > ItemY then
                        item.Position += UDim2.fromOffset(0, Height)
                    end
                end
            end
        end
    
        function Container:GetHeight(): number
            return self.Height
        end
    
    
        Frame.Name = "Container"
        Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Frame.BorderColor3 = Color3.new()
        Frame.BorderMode = Enum.BorderMode.Inset
        Frame.Size = UDim2.new(1, -6, 0, 0)
        Frame.Parent = Tab.self[Side]
    
        Container:UpdateSize(25)
        Tab.self[Side].CanvasSize += UDim2.fromOffset(0, 10)
        Tab[Container_Name] = Container
        return Container
    end
    
    
    function Menu.Label(Tab_Name: string, Container_Name: string, Name: string, ToolTip: string): Label
        local Container = GetContainer(Tab_Name, Container_Name)
        local GuiLabel = CreateLabel(Container.self, "Label", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
    
        GuiLabel.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, GuiLabel)
            end
        end)
        GuiLabel.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        local Label = {self = Label}
        Label.Name = Name
        Label.Class = "Label"
        Label.Index = #Items + 1
        Label.Tab = Tab_Name
        Label.Container = Container_Name
    
        function Label:SetLabel(Name: string)
            GuiLabel.Text = tostring(Name)
        end
    
        function Label:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if GuiLabel.Visible == Visible then return end
            
            GuiLabel.Visible = Visible
            Container:UpdateSize(Visible and 20 or -20, GuiLabel)
        end
    
        Container:UpdateSize(20)
        table.insert(Items, Label)
        return #Items
    end
    
    
    function Menu.Button(Tab_Name: string, Container_Name: string, Name: string, Callback: any, ToolTip: string): Button
        local Container = GetContainer(Tab_Name, Container_Name)
        local GuiButton = Instance.new("TextButton")
    
        local Button = {self = GuiButton}
        Button.Name = Name
        Button.Class = "Button"
        Button.Tab = Tab_Name
        Button.Container = Container_Name
        Button.Index = #Items + 1
        Button.Callback = typeof(Callback) == "function" and Callback or function() end
    
        
        function Button:SetLabel(Name: string)
            GuiButton.Text = tostring(Name)
        end
    
        function Button:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if GuiButton.Visible == Visible then return end
            
            GuiButton.Visible = Visible
            Container:UpdateSize(Visible and 25 or -25, GuiButton)
        end
    
    
        GuiButton.Name = "Button"
        GuiButton.BackgroundColor3 = Menu.ItemColor
        GuiButton.BorderColor3 = Menu.BorderColor
        GuiButton.BorderMode = Enum.BorderMode.Inset
        GuiButton.Position = UDim2.fromOffset(20, Container:GetHeight())
        GuiButton.Size = UDim2.new(1, -50, 0, 20)
        GuiButton.Font = Enum.Font.SourceSansSemibold
        GuiButton.Text = Name
        GuiButton.TextColor3 = Color3.new(1, 1, 1)
        GuiButton.TextSize = 14
        GuiButton.TextTruncate = Enum.TextTruncate.AtEnd
        GuiButton.Parent = Container.self
        CreateStroke(GuiButton, Color3.new(), 1)
        AddEventListener(GuiButton, function()
            GuiButton.BackgroundColor3 = Menu.ItemColor
            GuiButton.BorderColor3 = Menu.BorderColor
        end)
        GuiButton.MouseButton1Click:Connect(function()
            Button.Callback()
        end)
        GuiButton.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, GuiButton)
            end
        end)
        GuiButton.MouseLeave:Connect(function()
            Menu:SetToolTip(false)
        end)
    
        Container:UpdateSize(25)
        table.insert(Items, Button)
        return #Items
    end
    
    
    function Menu.TextBox(Tab_Name: string, Container_Name: string, Name: string, Value: string, Callback: any, ToolTip: string): TextBox
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "TextBox", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
        local GuiTextBox = Instance.new("TextBox")
    
        local TextBox = {self = GuiTextBox}
        TextBox.Name = Name
        TextBox.Class = "TextBox"
        TextBox.Tab = Tab_Name
        TextBox.Container = Container_Name
        TextBox.Index = #Items + 1
        TextBox.Value = typeof(Value) == "string" and Value or ""
        TextBox.Callback = typeof(Callback) == "function" and Callback or function() end
    
    
        function TextBox:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function TextBox:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 45 or -45, Label)
        end
    
        function TextBox:GetValue(): string
            return self.Value
        end
    
        function TextBox:SetValue(Value: string)
            self.Value = tostring(Value)
            GuiTextBox.Text = self.Value
        end
    
    
        GuiTextBox.Name = "TextBox"
        GuiTextBox.BackgroundColor3 = Menu.ItemColor
        GuiTextBox.BorderColor3 = Menu.BorderColor
        GuiTextBox.BorderMode = Enum.BorderMode.Inset
        GuiTextBox.Position = UDim2.fromOffset(0, 20)
        GuiTextBox.Size = UDim2.new(1, -50, 0, 20)
        GuiTextBox.Font = Enum.Font.SourceSansSemibold
        GuiTextBox.Text = TextBox.Value
        GuiTextBox.TextColor3 = Color3.new(1, 1, 1)
        GuiTextBox.TextSize = 14
        GuiTextBox.ClearTextOnFocus = false
        GuiTextBox.ClipsDescendants = true
        GuiTextBox.Parent = Label
        CreateStroke(GuiTextBox, Color3.new(), 1)
        AddEventListener(GuiTextBox, function()
            GuiTextBox.BackgroundColor3 = Menu.ItemColor
            GuiTextBox.BorderColor3 = Menu.BorderColor
        end)
        GuiTextBox.FocusLost:Connect(function()
            TextBox.Value = GuiTextBox.Text
            TextBox.Callback(GuiTextBox.Text)
        end)
        GuiTextBox.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, GuiTextBox)
            end
        end)
        GuiTextBox.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Container:UpdateSize(45)
        table.insert(Items, TextBox)
        return #Items
    end
    
    
    function Menu.CheckBox(Tab_Name: string, Container_Name: string, Name: string, Boolean: boolean, Callback: any, ToolTip: string): CheckBox
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "CheckBox", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        
        local CheckBox = {self = Label}
        CheckBox.Name = Name
        CheckBox.Class = "CheckBox"
        CheckBox.Tab = Tab_Name
        CheckBox.Container = Container_Name
        CheckBox.Index = #Items + 1
        CheckBox.Value = typeof(Boolean) == "boolean" and Boolean or false
        CheckBox.Callback = typeof(Callback) == "function" and Callback or function() end
    
    
        function CheckBox:Update(Value: boolean)
            self.Value = typeof(Value) == "boolean" and Value
            Button.BackgroundColor3 = self.Value and Menu.Accent or Menu.ItemColor
        end
    
        function CheckBox:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function CheckBox:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 20 or -20, Label)
        end
    
        function CheckBox:GetValue(): boolean
            return self.Value
        end
    
        function CheckBox:SetValue(Value: boolean)
            self:Update(Value)
        end
    
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.Position = UDim2.fromOffset(-14, 4)
        Button.Size = UDim2.fromOffset(8, 8)
        Button.Text = ""
        Button.Parent = Label
        AddEventListener(Button, function()
            Button.BackgroundColor3 = CheckBox.Value and Menu.Accent or Menu.ItemColor
        end)
        Button.MouseButton1Click:Connect(function()
            CheckBox:Update(not CheckBox.Value)
            CheckBox.Callback(CheckBox.Value)
        end)
    
        CheckBox:Update(CheckBox.Value)
        Container:UpdateSize(20)
        table.insert(Items, CheckBox)
        return #Items
    end
    
    
    function Menu.Hotkey(Tab_Name: string, Container_Name: string, Name: string, Key:EnumItem, Callback: any, ToolTip: string): Hotkey
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "Hotkey", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        local Selected_Hotkey = Instance.new("Frame")
        local HotkeyToggle = Instance.new("TextButton")
        local HotkeyHold = Instance.new("TextButton")
    
        local Hotkey = {self = Label}
        Hotkey.Name = Name
        Hotkey.Class = "Hotkey"
        Hotkey.Tab = Tab_Name
        Hotkey.Container = Container_Name
        Hotkey.Index = #Items + 1
        Hotkey.Key = typeof(Key) == "EnumItem" and Key or nil
        Hotkey.Callback = typeof(Callback) == "function" and Callback or function() end
        Hotkey.Editing = false
        Hotkey.Mode = "Toggle"
    
    
        function Hotkey:Update(Input: EnumItem, Mode: string)
            Button.Text = Input and string.format("[%s]", Input.Name) or "[None]"
    
            self.Key = Input
            self.Mode = Mode or "Toggle"
            self.Editing = false
        end
    
        function Hotkey:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function Hotkey:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 20 or -20, Label)
        end
    
        function Hotkey:GetValue(): EnumItem--, string
            return self.Key, self.Mode
        end
    
        function Hotkey:SetValue(Key: EnumItem, Mode: string)
            self:Update(Key, Mode)
        end
    
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Button.Name = "Hotkey"
        Button.BackgroundTransparency = 1
        Button.Position = UDim2.new(1, -100, 0, 4)
        Button.Size = UDim2.fromOffset(75, 8)
        Button.Font = Enum.Font.SourceSans
        Button.Text = Key and "[" .. Key.Name .. "]" or "[None]"
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.TextSize = 12
        Button.TextXAlignment = Enum.TextXAlignment.Right
        Button.Parent = Label
    
        Selected_Hotkey.Name = "Selected_Hotkey"
        Selected_Hotkey.Visible = false
        Selected_Hotkey.BackgroundColor3 = Menu.ItemColor
        Selected_Hotkey.BorderColor3 = Menu.BorderColor
        Selected_Hotkey.Position = UDim2.fromOffset(200, 100)
        Selected_Hotkey.Size = UDim2.fromOffset(100, 30)
        Selected_Hotkey.Parent = nil
        CreateStroke(Selected_Hotkey, Color3.new(), 1)
        AddEventListener(Selected_Hotkey, function()
            Selected_Hotkey.BackgroundColor3 = Menu.ItemColor
            Selected_Hotkey.BorderColor3 = Menu.BorderColor
        end)
    
        HotkeyToggle.Parent = Selected_Hotkey
        HotkeyToggle.BackgroundColor3 = Menu.ItemColor
        HotkeyToggle.BorderColor3 = Color3.new()
        HotkeyToggle.BorderSizePixel = 0
        HotkeyToggle.Position = UDim2.new()
        HotkeyToggle.Size = UDim2.new(1, 0, 0, 13)
        HotkeyToggle.Font = Enum.Font.SourceSans
        HotkeyToggle.Text = "Toggle"
        HotkeyToggle.TextColor3 = Menu.Accent
        HotkeyToggle.TextSize = 14
        AddEventListener(HotkeyToggle, function()
            HotkeyToggle.BackgroundColor3 = Menu.ItemColor
            if Hotkey.Mode == "Toggle" then
                HotkeyToggle.TextColor3 = Menu.Accent
            end
        end)
        HotkeyToggle.MouseButton1Click:Connect(function()
            Hotkey:Update(Hotkey.Key, "Toggle")
            HotkeyToggle.TextColor3 = Menu.Accent
            HotkeyHold.TextColor3 = Color3.new(1, 1, 1)
            UpdateSelected()
            Hotkey.Callback(Hotkey.Key, Hotkey.Mode)
        end)
    
        HotkeyHold.Parent = Selected_Hotkey
        HotkeyHold.BackgroundColor3 = Menu.ItemColor
        HotkeyHold.BorderColor3 = Color3.new()
        HotkeyHold.BorderSizePixel = 0
        HotkeyHold.Position = UDim2.new(0, 0, 0, 15)
        HotkeyHold.Size = UDim2.new(1, 0, 0, 13)
        HotkeyHold.Font = Enum.Font.SourceSans
        HotkeyHold.Text = "Hold"
        HotkeyHold.TextColor3 = Color3.new(1, 1, 1)
        HotkeyHold.TextSize = 14
        AddEventListener(HotkeyHold, function()
            HotkeyHold.BackgroundColor3 = Menu.ItemColor
            if Hotkey.Mode == "Hold" then
                HotkeyHold.TextColor3 = Menu.Accent
            end
        end)
        HotkeyHold.MouseButton1Click:Connect(function()
            Hotkey:Update(Hotkey.Key, "Hold")
            HotkeyHold.TextColor3 = Menu.Accent
            HotkeyToggle.TextColor3 = Color3.new(1, 1, 1)
            UpdateSelected()
            Hotkey.Callback(Hotkey.Key, Hotkey.Mode)
        end)
    
        Button.MouseButton1Click:Connect(function()
            Button.Text = "..."
            Hotkey.Editing = true
            if UserInput:IsKeyDown(HotkeyRemoveKey) and Key ~= HotkeyRemoveKey then
                Hotkey:Update()
                Hotkey.Callback(nil, Hotkey.Mode)
            end
        end)
        Button.MouseButton2Click:Connect(function()
            UpdateSelected(Selected_Hotkey, Button, UDim2.fromOffset(100, 0))
        end)
    
        UserInput.InputBegan:Connect(function(Input)
            if Hotkey.Editing then
                local Key = Input.KeyCode
                if Key == Enum.KeyCode.Unknown then
                    local InputType = Input.UserInputType
                    Hotkey:Update(InputType)
                    Hotkey.Callback(InputType, Hotkey.Mode)
                else
                    Hotkey:Update(Key)
                    Hotkey.Callback(Key, Hotkey.Mode)
                end
            end
        end)
    
        Container:UpdateSize(20)
        table.insert(Items, Hotkey)
        return #Items
    end
    
    
    function Menu.Slider(Tab_Name: string, Container_Name: string, Name: string, Min: number, Max: number, Value: number, Unit: string, Scale: number, Callback: any, ToolTip: string): Slider
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "Slider", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        local ValueBar = Instance.new("TextLabel")
        local ValueBox = Instance.new("TextBox")
        local ValueLabel = Instance.new("TextLabel")
    
        local Slider = {}
        Slider.Name = Name
        Slider.Class = "Slider"
        Slider.Tab = Tab_Name
        Slider.Container = Container_Name
        Slider.Index = #Items + 1
        Slider.Min = typeof(Min) == "number" and math.clamp(Min, Min, Max) or 0
        Slider.Max = typeof(Max) == "number" and Max or 100
        Slider.Value = typeof(Value) == "number" and Value or 100
        Slider.Unit = typeof(Unit) == "string" and Unit or ""
        Slider.Scale = typeof(Scale) == "number" and Scale or 0
        Slider.Callback = typeof(Callback) == "function" and Callback or function() end
    
    
        local function UpdateSlider(Percentage: number)
            local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
            local Value = Slider.Min + ((Slider.Max - Slider.Min) * Percentage)
            local Scale = (10 ^ Slider.Scale)
            Slider.Value = math.round(Value * Scale) / Scale
    
            ValueBar.Size = UDim2.new(Percentage, 0, 0, 5)
            ValueBox.Text = "[" .. Slider.Value .. "]"
            ValueLabel.Text = Slider.Value .. Slider.Unit
        end
    
    
        function Slider:Update(Percentage: number)
            UpdateSlider(Percentage)
        end
    
        function Slider:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function Slider:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 30 or -30, Label)
        end
    
        function Slider:GetValue(): number
            return self.Value
        end
    
        function Slider:SetValue(Value: number)
            self.Value = typeof(Value) == "number" and math.clamp(Value, self.Min, self.Max) or self.Min
            local Percentage = (self.Value - self.Min) / (self.Max - self.Min)
            self:Update(Percentage)
        end
    
        Slider.self = Label
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            Menu:SetToolTip(false)
        end)
    
        Button.Name = "Slider"
        Button.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        Button.BorderColor3 = Color3.new()
        Button.Position = UDim2.fromOffset(0, 20)
        Button.Size = UDim2.new(1, -40, 0, 5)
        Button.Text = ""
        Button.AutoButtonColor = false
        Button.Parent = Label
    
        ValueBar.Name = "ValueBar"
        ValueBar.BackgroundColor3 = Menu.Accent
        ValueBar.BorderSizePixel = 0
        ValueBar.Size = UDim2.fromScale(1, 1)
        ValueBar.Text = ""
        ValueBar.Parent = Button
        AddEventListener(ValueBar, function()
            ValueBar.BackgroundColor3 = Menu.Accent
        end)
        
        ValueBox.Name = "ValueBox"
        ValueBox.BackgroundTransparency = 1
        ValueBox.Position = UDim2.new(1, -65, 0, 5)
        ValueBox.Size = UDim2.fromOffset(50, 10)
        ValueBox.Font = Enum.Font.SourceSans
        ValueBox.Text = ""
        ValueBox.TextColor3 = Color3.new(1, 1, 1)
        ValueBox.TextSize = 12
        ValueBox.TextXAlignment = Enum.TextXAlignment.Right
        ValueBox.ClipsDescendants = true
        ValueBox.Parent = Label
        ValueBox.FocusLost:Connect(function()
            Slider.Value = tonumber(ValueBox.Text) or 0
            local Percentage = (Slider.Value - Slider.Min) / (Slider.Max - Slider.Min)
            Slider:Update(Percentage)
            Slider.Callback(Slider.Value)
        end)
    
        ValueLabel.Name = "ValueLabel"
        ValueLabel.BackgroundTransparency = 1
        ValueLabel.Position = UDim2.new(1, 0, 0, 2)
        ValueLabel.Size = UDim2.new(0, 0, 1, 0)
        ValueLabel.Font = Enum.Font.SourceSansBold
        ValueLabel.Text = ""
        ValueLabel.TextColor3 = Color3.new(1, 1, 1)
        ValueLabel.TextSize = 14
        ValueLabel.Parent = ValueBar
    
        Button.InputBegan:Connect(function(Input: InputObject, Process: boolean)
            if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                Dragging = {Gui = Button, True = true}
                local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                local Percentage = (InputPosition - Button.AbsolutePosition) / Button.AbsoluteSize
                Slider:Update(Percentage.X)
                Slider.Callback(Slider.Value)
            end
        end)
    
        UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
            if Dragging.Gui ~= Button then return end
            if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
                Dragging = {Gui = nil, True = false}
                return
            end
            if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
                local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                local Percentage = (InputPosition - Button.AbsolutePosition) / Button.AbsoluteSize
                Slider:Update(Percentage.X)
                Slider.Callback(Slider.Value)
            end
        end)
    
    
        Slider:SetValue(Slider.Value)
        Container:UpdateSize(30)
        table.insert(Items, Slider)
        return #Items
    end
    
    
    function Menu.ColorPicker(Tab_Name: string, Container_Name: string, Name: string, Color: Color3, Alpha: number, Callback: any, ToolTip: string): ColorPicker
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "ColorPicker", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        local Selected_ColorPicker = Instance.new("Frame")
        local HexBox = Instance.new("TextBox")
        local Saturation = Instance.new("ImageButton")
        local Alpha = Instance.new("ImageButton")
        local Hue = Instance.new("ImageButton")
        local SaturationCursor = Instance.new("Frame")
        local AlphaCursor = Instance.new("Frame")
        local HueCursor = Instance.new("Frame")
        local CopyButton = Instance.new("TextButton") -- rbxassetid://9090721920
        local PasteButton = Instance.new("TextButton") -- rbxassetid://9090721063
        local AlphaColorGradient = Instance.new("UIGradient")
    
        local ColorPicker = {self = Label}
        ColorPicker.Name = Name
        ColorPicker.Tab = Tab_Name
        ColorPicker.Class = "ColorPicker"
        ColorPicker.Container = Container_Name
        ColorPicker.Index = #Items + 1
        ColorPicker.Color = typeof(Color) == "Color3" and Color or Color3.new(1, 1, 1)
        ColorPicker.Saturation = {0, 0} -- no i'm not going to use ColorPicker.Value that would confuse people with ColorPicker.Color
        ColorPicker.Alpha = typeof(Alpha) == "number" and Alpha or 0
        ColorPicker.Hue = 0
        ColorPicker.Callback = typeof(Callback) == "function" and Callback or function() end
    
    
        local function UpdateColor()
            ColorPicker.Color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2])
    
            HexBox.Text = "#" .. string.upper(ColorPicker.Color:ToHex()) .. string.upper(string.format("%X", ColorPicker.Alpha * 255))
            Button.BackgroundColor3 = ColorPicker.Color
            Saturation.BackgroundColor3 = ColorPicker.Color
            AlphaColorGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, ColorPicker.Color)}
    
            SaturationCursor.Position = UDim2.fromScale(math.clamp(ColorPicker.Saturation[1], 0, 0.95), math.clamp(1 - ColorPicker.Saturation[2], 0, 0.95))
            AlphaCursor.Position = UDim2.fromScale(0, math.clamp(ColorPicker.Alpha, 0, 0.98))
            HueCursor.Position = UDim2.fromScale(0, math.clamp(ColorPicker.Hue, 0, 0.98))
    
            ColorPicker.Callback(ColorPicker.Color, ColorPicker.Alpha)
        end
    
    
        function ColorPicker:Update()
            UpdateColor()
        end
    
        function ColorPicker:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function ColorPicker:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 20 or -20, Label)
        end
    
        function ColorPicker:SetValue(Color: Color3, Alpha: number)
            self.Color, self.Alpha = typeof(Color) == "Color3" and Color or Color3.new(), typeof(Alpha) == "number" and Alpha or 0
            self.Hue, self.Saturation[1], self.Saturation[2] = self.Color:ToHSV()
            self:Update()
        end
    
        function ColorPicker:GetValue(): Color3--, number
            return self.Color, self.Alpha
        end
    
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Button.Name = "ColorPicker"
        Button.BackgroundColor3 = ColorPicker.Color
        Button.BorderColor3 = Color3.new()
        Button.Position = UDim2.new(1, -35, 0, 4)
        Button.Size = UDim2.fromOffset(20, 8)
        Button.Font = Enum.Font.SourceSans
        Button.Text = ""
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.TextSize = 12
        Button.Parent = Label
        Button.MouseButton1Click:Connect(function()
            UpdateSelected(Selected_ColorPicker, Button, UDim2.fromOffset(20, 20))
        end)
    
        Selected_ColorPicker.Name = "Selected_ColorPicker"
        Selected_ColorPicker.Visible = false
        Selected_ColorPicker.BackgroundColor3 = Menu.ItemColor
        Selected_ColorPicker.BorderColor3 = Menu.BorderColor
        Selected_ColorPicker.BorderMode = Enum.BorderMode.Inset
        Selected_ColorPicker.Position = UDim2.new(0, 200, 0, 170)
        Selected_ColorPicker.Size = UDim2.new(0, 190, 0, 180)
        Selected_ColorPicker.Parent = nil
        CreateStroke(Selected_ColorPicker, Color3.new(), 1)
        AddEventListener(Selected_ColorPicker, function()
            Selected_ColorPicker.BackgroundColor3 = Menu.ItemColor
            Selected_ColorPicker.BorderColor3 = Menu.BorderColor
        end)
    
        HexBox.Name = "Hex"
        HexBox.BackgroundColor3 = Menu.ItemColor
        HexBox.BorderColor3 = Menu.BorderColor
        HexBox.BorderMode = Enum.BorderMode.Inset
        HexBox.Size = UDim2.new(1, -10, 0, 20)
        HexBox.Position = UDim2.fromOffset(5, 150)
        HexBox.Text = "#" .. string.upper(ColorPicker.Color:ToHex())
        HexBox.Font = Enum.Font.SourceSansSemibold
        HexBox.TextSize = 14
        HexBox.TextColor3 = Color3.new(1, 1, 1)
        HexBox.ClearTextOnFocus = false
        HexBox.ClipsDescendants = true
        HexBox.Parent = Selected_ColorPicker
        CreateStroke(HexBox, Color3.new(), 1)
        HexBox.FocusLost:Connect(function()
            pcall(function()
                local Color, Alpha = string.sub(HexBox.Text, 1, 7), string.sub(HexBox.Text, 8, #HexBox.Text)
                ColorPicker.Color = Color3.fromHex(Color)
                ColorPicker.Alpha = tonumber(Alpha, 16) / 255
                ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2] = ColorPicker.Color:ToHSV()
                ColorPicker:Update()
            end)
        end)
        AddEventListener(HexBox, function()
            HexBox.BackgroundColor3 = Menu.ItemColor
            HexBox.BorderColor3 = Menu.BorderColor
        end)
    
        Saturation.Name = "Saturation"
        Saturation.BackgroundColor3 = ColorPicker.Color
        Saturation.BorderColor3 = Menu.BorderColor
        Saturation.Position = UDim2.new(0, 4, 0, 4)
        Saturation.Size = UDim2.new(0, 150, 0, 140)
        Saturation.Image = "rbxassetid://8180999986"
        Saturation.ImageColor3 = Color3.new()
        Saturation.AutoButtonColor = false
        Saturation.Parent = Selected_ColorPicker
        CreateStroke(Saturation, Color3.new(), 1)
        AddEventListener(Saturation, function()
            Saturation.BorderColor3 = Menu.BorderColor
        end)
        
        Alpha.Name = "Alpha"
        Alpha.BorderColor3 = Menu.BorderColor
        Alpha.Position = UDim2.new(0, 175, 0, 4)
        Alpha.Size = UDim2.new(0, 10, 0, 140)
        Alpha.Image = "rbxassetid://9090739505"--"rbxassetid://8181003956"
        Alpha.ScaleType = Enum.ScaleType.Crop
        Alpha.AutoButtonColor = false
        Alpha.Parent = Selected_ColorPicker
        CreateStroke(Alpha, Color3.new(), 1)
        AddEventListener(Alpha, function()
            Alpha.BorderColor3 = Menu.BorderColor
        end)
    
        Hue.Name = "Hue"
        Hue.BackgroundColor3 = Color3.new(1, 1, 1)
        Hue.BorderColor3 = Menu.BorderColor
        Hue.Position = UDim2.new(0, 160, 0, 4)
        Hue.Size = UDim2.new(0, 10, 0, 140)
        Hue.Image = "rbxassetid://8180989234"
        Hue.ScaleType = Enum.ScaleType.Crop
        Hue.AutoButtonColor = false
        Hue.Parent = Selected_ColorPicker
        CreateStroke(Hue, Color3.new(), 1)
        AddEventListener(Hue, function()
            Hue.BorderColor3 = Menu.BorderColor
        end)
    
        SaturationCursor.Name = "Cursor"
        SaturationCursor.BackgroundColor3 = Color3.new(1, 1, 1)
        SaturationCursor.BorderColor3 = Color3.new()
        SaturationCursor.Size = UDim2.fromOffset(5, 5)
        SaturationCursor.Parent = Saturation
    
        AlphaCursor.Name = "Cursor"
        AlphaCursor.BackgroundColor3 = Color3.new(1, 1, 1)
        AlphaCursor.BorderColor3 = Color3.new()
        AlphaCursor.Size = UDim2.new(1, 0, 0, 2)
        AlphaCursor.Parent = Alpha
    
        HueCursor.Name = "Cursor"
        HueCursor.BackgroundColor3 = Color3.new(1, 1, 1)
        HueCursor.BorderColor3 = Color3.new()
        HueCursor.Size = UDim2.new(1, 0, 0, 2)
        HueCursor.Parent = Hue
    
        AlphaColorGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, ColorPicker.Color)}
        AlphaColorGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.20), NumberSequenceKeypoint.new(1, 0.2)}
        AlphaColorGradient.Offset = Vector2.new(0, -0.1)
        AlphaColorGradient.Rotation = -90
        AlphaColorGradient.Parent = Alpha
    
        local function UpdateSaturation(PercentageX: number, PercentageY: number)
            local PercentageX = typeof(PercentageX == "number") and math.clamp(PercentageX, 0, 1) or 0
            local PercentageY = typeof(PercentageY == "number") and math.clamp(PercentageY, 0, 1) or 0
            ColorPicker.Saturation[1] = PercentageX
            ColorPicker.Saturation[2] = 1 - PercentageY
            ColorPicker:Update()
        end
    
        local function UpdateAlpha(Percentage: number)
            local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
            ColorPicker.Alpha = Percentage
            ColorPicker:Update()
        end
    
        local function UpdateHue(Percentage: number)
            local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
            ColorPicker.Hue = Percentage
            ColorPicker:Update()
        end
    
        Saturation.InputBegan:Connect(function(Input: InputObject, Process: boolean)
            if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                Dragging = {Gui = Saturation, True = true}
                local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                local Percentage = (InputPosition - Saturation.AbsolutePosition) / Saturation.AbsoluteSize
                UpdateSaturation(Percentage.X, Percentage.Y)
            end
        end)
    
        Alpha.InputBegan:Connect(function(Input: InputObject, Process: boolean)
            if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                Dragging = {Gui = Alpha, True = true}
                local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                local Percentage = (InputPosition - Alpha.AbsolutePosition) / Alpha.AbsoluteSize
                UpdateAlpha(Percentage.Y)
            end
        end)
    
        Hue.InputBegan:Connect(function(Input: InputObject, Process: boolean)
            if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                Dragging = {Gui = Hue, True = true}
                local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
                local Percentage = (InputPosition - Hue.AbsolutePosition) / Hue.AbsoluteSize
                UpdateHue(Percentage.Y)
            end
        end)
    
        UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
            if (Dragging.Gui ~= Saturation and Dragging.Gui ~= Alpha and Dragging.Gui ~= Hue) then return end
            if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
                Dragging = {Gui = nil, True = false}
                return
            end
    
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
                if Dragging.Gui == Saturation then
                    local Percentage = (InputPosition - Saturation.AbsolutePosition) / Saturation.AbsoluteSize
                    UpdateSaturation(Percentage.X, Percentage.Y)
                end
                if Dragging.Gui == Alpha then
                    local Percentage = (InputPosition - Alpha.AbsolutePosition) / Alpha.AbsoluteSize
                    UpdateAlpha(Percentage.Y)
                end
                if Dragging.Gui == Hue then
                    local Percentage = (InputPosition - Hue.AbsolutePosition) / Hue.AbsoluteSize
                    UpdateHue(Percentage.Y)
                end
            end
        end)
        
        
        ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2] = ColorPicker.Color:ToHSV()
        ColorPicker:Update()
        Container:UpdateSize(20)
        table.insert(Items, ColorPicker)
        return #Items
    end
    
    
    function Menu.ComboBox(Tab_Name: string, Container_Name: string, Name: string, Value: string, Value_Items: table, Callback: any, ToolTip: string): ComboBox
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "ComboBox", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        local Symbol = Instance.new("TextLabel")
        local List = Instance.new("ScrollingFrame")
        local ListLayout = Instance.new("UIListLayout")
    
        local ComboBox = {}
        ComboBox.Name = Name
        ComboBox.Class = "ComboBox"
        ComboBox.Tab = Tab_Name
        ComboBox.Container = Container_Name
        ComboBox.Index = #Items + 1
        ComboBox.Callback = typeof(Callback) == "function" and Callback or function() end
        ComboBox.Value = typeof(Value) == "string" and Value or ""
        ComboBox.Items = typeof(Value_Items) == "table" and Value_Items or {}
    
        local function UpdateValue(Value: string)
            ComboBox.Value = tostring(Value)
            Button.Text = ComboBox.Value or "[...]"
        end
    
        local ItemObjects = {}
        local function AddItem(Name: string)
            local Button = Instance.new("TextButton")
            Button.BackgroundColor3 = Menu.ItemColor
            Button.BorderColor3 = Color3.new()
            Button.BorderSizePixel = 0
            Button.Size = UDim2.new(1, 0, 0, 15)
            Button.Font = Enum.Font.SourceSans
            Button.Text = tostring(Name)
            Button.TextColor3 = ComboBox.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
            Button.TextSize = 14
            Button.TextTruncate = Enum.TextTruncate.AtEnd
            Button.Parent = List
            Button.MouseButton1Click:Connect(function()
                for _, v in ipairs(List:GetChildren()) do
                    if v:IsA("GuiButton") then
                        if v == Button then continue end
                        v.TextColor3 = Color3.new(1, 1, 1)
                    end
                end
                Button.TextColor3 = Menu.Accent
                UpdateValue(Button.Text)
                UpdateSelected()
                ComboBox.Callback(ComboBox.Value)
            end)
            AddEventListener(Button, function()
                Button.BackgroundColor3 = Menu.ItemColor
                if ComboBox.Value == Button.Text then
                    Button.TextColor3 = Menu.Accent
                else
                    Button.TextColor3 = Color3.new(1, 1, 1)
                end
            end)
            
            if #ComboBox.Items >= 6 then
                List.CanvasSize += UDim2.fromOffset(0, 15)
            end
            table.insert(ItemObjects, Button)
        end
    
    
        function ComboBox:Update(Value: string, Items: any)
            UpdateValue(Value)
            if typeof(Items) == "table" then
                for _, Button in ipairs(ItemObjects) do
                    Button:Destroy()
                end
                table.clear(ItemObjects)
    
                List.CanvasSize = UDim2.new()
                List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#self.Items * 15, 15, 90))
                for _, Item in ipairs(self.Items) do
                    AddItem(tostring(Item))
                end
            else
                for _, Button in ipairs(ItemObjects) do
                    Button.TextColor3 = self.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
                end
            end
        end
    
        function ComboBox:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function ComboBox:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 40 or -40, Label)
        end
    
        function ComboBox:GetValue(): table
            return self.Value
        end
    
        function ComboBox:SetValue(Value: string, Items: any)
            if typeof(Items) == "table" then
                self.Items = Items
            end
            self:Update(Value, self.Items)
        end
    
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Button.Name = "Button"
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.Position = UDim2.new(0, 0, 0, 20)
        Button.Size = UDim2.new(1, -40, 0, 15)
        Button.Font = Enum.Font.SourceSans
        Button.Text = ComboBox.Value
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.TextSize = 14
        Button.TextTruncate = Enum.TextTruncate.AtEnd
        Button.Parent = Label
        Button.MouseButton1Click:Connect(function()
            UpdateSelected(List, Button, UDim2.fromOffset(0, 15))
            List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#ComboBox.Items * 15, 15, 90))
        end)
        AddEventListener(Button, function()
            Button.BackgroundColor3 = Menu.ItemColor
        end)
    
        Symbol.Name = "Symbol"
        Symbol.Parent = Button
        Symbol.BackgroundColor3 = Color3.new(1, 1, 1)
        Symbol.BackgroundTransparency = 1
        Symbol.Position = UDim2.new(1, -10, 0, 0)
        Symbol.Size = UDim2.new(0, 5, 1, 0)
        Symbol.Font = Enum.Font.SourceSans
        Symbol.Text = "-"
        Symbol.TextColor3 = Color3.new(1, 1, 1)
        Symbol.TextSize = 14
    
        List.Visible = false
        List.BackgroundColor3 = Menu.ItemColor
        List.BorderColor3 = Menu.BorderColor
        List.BorderMode = Enum.BorderMode.Inset
        List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#ComboBox.Items * 15, 15, 90))
        List.Position = UDim2.fromOffset(20, 30)
        List.CanvasSize = UDim2.new()
        List.ScrollBarThickness = 4
        List.ScrollBarImageColor3 = Menu.Accent
        List.Parent = Label
        CreateStroke(List, Color3.new(), 1)
        AddEventListener(List, function()
            List.BackgroundColor3 = Menu.ItemColor
            List.BorderColor3 = Menu.BorderColor
            List.ScrollBarImageColor3 = Menu.Accent
        end)
    
        ListLayout.Parent = List
    
        ComboBox:Update(ComboBox.Value, ComboBox.Items)
        Container:UpdateSize(40)
        table.insert(Items, ComboBox)
        return #Items
    end
    
    
    function Menu.MultiSelect(Tab_Name: string, Container_Name: string, Name: string, Value_Items: table, Callback: any, ToolTip: string): MultiSelect
        local Container = GetContainer(Tab_Name, Container_Name)
        local Label = CreateLabel(Container.self, "MultiSelect", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
        local Button = Instance.new("TextButton")
        local Symbol = Instance.new("TextLabel")
        local List = Instance.new("ScrollingFrame")
        local ListLayout = Instance.new("UIListLayout")
    
        local MultiSelect = {self = Label}
        MultiSelect.Name = Name
        MultiSelect.Class = "MultiSelect"
        MultiSelect.Tab = Tab_Name
        MultiSelect.Container = Container_Name
        MultiSelect.Index = #Items + 1
        MultiSelect.Callback = typeof(Callback) == "function" and Callback or function() end
        MultiSelect.Items = typeof(Value_Items) == "table" and Value_Items or {}
        MultiSelect.Value = {}
    
    
        local function GetSelectedItems(): table
            local Selected = {}
            for k, v in pairs(MultiSelect.Items) do
                if v == true then table.insert(Selected, k) end
            end
            return Selected
        end
    
        local function UpdateValue()
            MultiSelect.Value = GetSelectedItems()
            Button.Text = #MultiSelect.Value > 0 and table.concat(MultiSelect.Value, ", ") or "[...]"
        end
    
        local ItemObjects = {}
        local function AddItem(Name: string, Checked: boolean)
            local Button = Instance.new("TextButton")
            Button.BackgroundColor3 = Menu.ItemColor
            Button.BorderColor3 = Color3.new()
            Button.BorderSizePixel = 0
            Button.Size = UDim2.new(1, 0, 0, 15)
            Button.Font = Enum.Font.SourceSans
            Button.Text = Name
            Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
            Button.TextSize = 14
            Button.Parent = List
            Button.TextTruncate = Enum.TextTruncate.AtEnd
            Button.MouseButton1Click:Connect(function()
                MultiSelect.Items[Name] = not MultiSelect.Items[Name]
                Button.TextColor3 = MultiSelect.Items[Name] and Menu.Accent or Color3.new(1, 1, 1)
                UpdateValue()
                MultiSelect.Callback(MultiSelect.Items) -- don't send value
            end)
            AddEventListener(Button, function()
                Button.BackgroundColor3 = Menu.ItemColor
                Button.TextColor3 = table.find(GetSelectedItems(), Button.Text) and Menu.Accent or Color3.new(1, 1, 1)
            end)
    
            if GetDictionaryLength(MultiSelect.Items) >= 6 then
                List.CanvasSize += UDim2.fromOffset(0, 15)
            end
            table.insert(ItemObjects, Button)
        end
    
    
        function MultiSelect:Update(Value: any)
            if typeof(Value) == "table" then
                self.Items = Value
                UpdateValue()
    
                for _, Button in ipairs(ItemObjects) do
                    Button:Destroy()
                end
                table.clear(ItemObjects)
    
                List.CanvasSize = UDim2.new()
                List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(self.Items) * 15, 15, 90))
                for Name, Checked in pairs(self.Items) do
                    AddItem(tostring(Name), Checked)
                end
            else
                local Selected = GetSelectedItems()
                for _, Button in ipairs(ItemObjects) do
                    local Checked = table.find(Selected, Button.Text)
                    Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
                end
            end
        end
    
        function MultiSelect:SetLabel(Name: string)
            Label.Text = tostring(Name)
        end
    
        function MultiSelect:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Label.Visible == Visible then return end
            
            Label.Visible = Visible
            Container:UpdateSize(Visible and 40 or -40, Label)
        end
    
        function MultiSelect:GetValue(): table
            return self.Items
        end
    
        function MultiSelect:SetValue(Value: any)
            self:Update(Value)
        end
    
    
        Label.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, Label)
            end
        end)
        Label.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
    
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.Position = UDim2.new(0, 0, 0, 20)
        Button.Size = UDim2.new(1, -40, 0, 15)
        Button.Font = Enum.Font.SourceSans
        Button.Text = "[...]"
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.TextSize = 14
        Button.TextTruncate = Enum.TextTruncate.AtEnd
        Button.Parent = Label
        Button.MouseButton1Click:Connect(function()
            UpdateSelected(List, Button, UDim2.fromOffset(0, 15))
            List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(MultiSelect.Items) * 15, 15, 90))
        end)
        AddEventListener(Button, function()
            Button.BackgroundColor3 = Menu.ItemColor
        end)
    
        Symbol.Name = "Symbol"
        Symbol.BackgroundTransparency = 1
        Symbol.Position = UDim2.new(1, -10, 0, 0)
        Symbol.Size = UDim2.new(0, 5, 1, 0)
        Symbol.Font = Enum.Font.SourceSans
        Symbol.Text = "-"
        Symbol.TextColor3 = Color3.new(1, 1, 1)
        Symbol.TextSize = 14
        Symbol.Parent = Button
    
        List.Visible = false
        List.BackgroundColor3 = Menu.ItemColor
        List.BorderColor3 = Menu.BorderColor
        List.BorderMode = Enum.BorderMode.Inset
        List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(MultiSelect.Items) * 15, 15, 90))
        List.Position = UDim2.fromOffset(20, 30)
        List.CanvasSize = UDim2.new()
        List.ScrollBarThickness = 4
        List.ScrollBarImageColor3 = Menu.Accent
        List.Parent = Label
        CreateStroke(List, Color3.new(), 1)
        AddEventListener(List, function()
            List.BackgroundColor3 = Menu.ItemColor
            List.BorderColor3 = Menu.BorderColor
            List.ScrollBarImageColor3 = Menu.Accent
        end)
    
        ListLayout.Parent = List
    
        MultiSelect:Update(MultiSelect.Items)
        Container:UpdateSize(40)
        table.insert(Items, MultiSelect)
        return #Items
    end
    
    
    function Menu.ListBox(Tab_Name: string, Container_Name: string, Name: string, Multi: boolean, Value_Items: table, Callback: any, ToolTip: string): ListBox
        local Container = GetContainer(Tab_Name, Container_Name)
        local List = Instance.new("ScrollingFrame")
        local ListLayout = Instance.new("UIListLayout")
    
        local ListBox = {self = Label}
        ListBox.Name = Name
        ListBox.Class = "ListBox"
        ListBox.Tab = Tab_Name
        ListBox.Container = Container_Name
        ListBox.Index = #Items + 1
        ListBox.Method = Multi and "Multi" or "Default"
        ListBox.Items = typeof(Value_Items) == "table" and Value_Items or {}
        ListBox.Value = {}
        ListBox.Callback = typeof(Callback) == "function" and Callback or function() end
    
        local ItemObjects = {}
    
        local function GetSelectedItems(): table
            local Selected = {}
            for k, v in pairs(ListBox.Items) do
                if v == true then table.insert(Selected, k) end
            end
            return Selected
        end
    
        local function UpdateValue(Value: any)
            if ListBox.Method == "Default" then
                ListBox.Value = tostring(Value)
            else
                ListBox.Value = GetSelectedItems()
            end
        end
    
        local function AddItem(Name: string, Checked: boolean)
            local Button = Instance.new("TextButton")
            Button.BackgroundColor3 = Menu.ItemColor
            Button.BorderColor3 = Color3.new()
            Button.BorderSizePixel = 0
            Button.Size = UDim2.new(1, 0, 0, 15)
            Button.Font = Enum.Font.SourceSans
            Button.Text = Name
            Button.TextSize = 14
            Button.TextXAlignment = Enum.TextXAlignment.Left
            Button.TextTruncate = Enum.TextTruncate.AtEnd
            Button.Parent = List
            if ListBox.Method == "Default" then
                Button.TextColor3 = ListBox.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
                Button.MouseButton1Click:Connect(function()
                    for _, v in ipairs(List:GetChildren()) do
                        if v:IsA("GuiButton") then
                            if v == Button then continue end
                            v.TextColor3 = Color3.new(1, 1, 1)
                        end
                    end
                    Button.TextColor3 = Menu.Accent
                    UpdateValue(Button.Text)
                    UpdateSelected()
                    ListBox.Callback(ListBox.Value)
                end)
                AddEventListener(Button, function()
                    Button.BackgroundColor3 = Menu.ItemColor
                    if ListBox.Value == Button.Text then
                        Button.TextColor3 = Menu.Accent
                    else
                        Button.TextColor3 = Color3.new(1, 1, 1)
                    end
                end)
                
                if #ListBox.Items >= 6 then
                    List.CanvasSize += UDim2.fromOffset(0, 15)
                end
            else
                Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
                Button.MouseButton1Click:Connect(function()
                    ListBox.Items[Name] = not ListBox.Items[Name]
                    Button.TextColor3 = ListBox.Items[Name] and Menu.Accent or Color3.new(1, 1, 1)
                    UpdateValue()
                    UpdateSelected()
                    ListBox.Callback(ListBox.Value)
                end)
                AddEventListener(Button, function()
                    Button.BackgroundColor3 = Menu.ItemColor
                    if table.find(ListBox.Value, Name) then
                        Button.TextColor3 = Menu.Accent
                    else
                        Button.TextColor3 = Color3.new(1, 1, 1)
                    end
                end)
                
                if GetDictionaryLength(ListBox.Items) >= 10 then
                    List.CanvasSize += UDim2.fromOffset(0, 15)
                end
            end
            table.insert(ItemObjects, Button)
        end
    
    
        function ListBox:Update(Value: string, Items: any)
            if self.Method == "Default" then
                UpdateValue(Value)
            end
            if typeof(Items) == "table" then
                if self.Method == "Multi" then
                    self.Items = Value
                    UpdateValue()
                end
                for _, Button in ipairs(ItemObjects) do
                    Button:Destroy()
                end
                table.clear(ItemObjects)
    
                List.CanvasSize = UDim2.new()
                List.Size = UDim2.new(1, -50, 0, 150)
                if self.Method == "Default" then
                    for _, Item in ipairs(self.Items) do
                        AddItem(tostring(Item))
                    end
                else
                    for Name, Checked in pairs(self.Items) do
                        AddItem(tostring(Name), Checked)
                    end
                end
            else
                if self.Method == "Default" then
                    for _, Button in ipairs(ItemObjects) do
                        Button.TextColor3 = self.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
                    end
                else
                    local Selected = GetSelectedItems()
                    for _, Button in ipairs(ItemObjects) do
                        local Checked = table.find(Selected, Button.Text)
                        Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
                    end
                end
            end
        end
    
        function ListBox:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if List.Visible == Visible then return end
            
            List.Visible = Visible
            Container:UpdateSize(Visible and 155 or -155, List)
        end
    
        function ListBox:SetValue(Value: string, Items: any)
            if self.Method == "Default" then
                if typeof(Items) == "table" then
                    self.Items = Items
                end
                self:Update(Value, self.Items)
            else
                self:Update(Value)
            end
        end
    
        function ListBox:GetValue(): table
            return self.Value
        end
    
    
        List.Name = "List"
        List.Active = true
        List.BackgroundColor3 = Menu.ItemColor
        List.BorderColor3 = Color3.new()
        List.Position = UDim2.fromOffset(20, Container:GetHeight())
        List.Size = UDim2.new(1, -50, 0, 150)
        List.CanvasSize = UDim2.new()
        List.ScrollBarThickness = 4
        List.ScrollBarImageColor3 = Menu.Accent
        List.Parent = Container.self
        List.MouseEnter:Connect(function()
            if ToolTip then
                Menu:SetToolTip(true, ToolTip, List)
            end
        end)
        List.MouseLeave:Connect(function()
            if ToolTip then
                Menu:SetToolTip(false)
            end
        end)
        CreateStroke(List, Color3.new(), 1)
        AddEventListener(List, function()
            List.BackgroundColor3 = Menu.ItemColor
            List.ScrollBarImageColor3 = Menu.Accent
        end)
    
        ListLayout.Parent = List
    
        if ListBox.Method == "Default" then
            ListBox:Update(ListBox.Value, ListBox.Items)
        else
            ListBox:Update(ListBox.Items)
        end
        Container:UpdateSize(155)
        table.insert(Items, ListBox)
        return #Items
    end
    
    
    function Menu.Notify(Content: string, Delay: number)
        assert(typeof(Content) == "string", "missing argument #1, (string expected got " .. typeof(Content) .. ")")
        local Delay = typeof(Delay) == "number" and Delay or 3
    
        local Text = Instance.new("TextLabel")
        local Notification = {
            self = Text,
            Class = "Notification"
        }
    
        Text.Name = "Notification"
        Text.BackgroundTransparency = 1
        Text.Position = UDim2.new(0.5, -100, 1, -150 - (GetDictionaryLength(Notifications) * 15))
        Text.Size = UDim2.new(0, 0, 0, 15)
        Text.Text = Content
        Text.Font = Enum.Font.SourceSans
        Text.TextSize = 17
        Text.TextColor3 = Color3.new(1, 1, 1)
        Text.TextStrokeTransparency = 0.2
        Text.TextTransparency = 1
        Text.RichText = true
        Text.ZIndex = 4
        Text.Parent = Notifications_Frame
    
        local function CustomTweenOffset(Offset: number)
            spawn(function()
                local Steps = 33
                for i = 1, Steps do
                    Text.Position += UDim2.fromOffset(Offset / Steps, 0)
                    RunService.RenderStepped:Wait()
                end
            end)
        end
    
        function Notification:Update()
            
        end
    
        function Notification:Destroy()
            Notifications[self] = nil
            Text:Destroy()
    
            local Index = 1
            for _, v in pairs(Notifications) do
                local self = v.self
                self.Position += UDim2.fromOffset(0, 15)
                Index += 1
            end
        end
    
        Notifications[Notification] = Notification
        
        local TweenIn  = TweenService:Create(Text, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 0})
        local TweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 1})
        
        TweenIn:Play()
        CustomTweenOffset(100)
        
        TweenIn.Completed:Connect(function()
            delay(Delay, function()
                TweenOut:Play()
                CustomTweenOffset(100)
    
                TweenOut.Completed:Connect(function()
                    Notification:Destroy()
                end)
            end)
        end)
    end
    
    
    function Menu.Prompt(Message: string, Callback: any, ...)
        do
            local Prompt = Menu.Screen:FindFirstChild("Prompt")
            if Prompt then Prompt:Destroy() end
        end
    
        local Prompt = Instance.new("Frame")
        local Title = Instance.new("TextLabel")
    
        local Height = -20
        local function CreateButton(Text, Callback, ...)
            local Arguments = {...}
    
            local Callback = typeof(Callback) == "function" and Callback or function() end
            local Button = Instance.new("TextButton")
            Button.Name = "Button"
            Button.BorderSizePixel = 0
            Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            Button.Size = UDim2.fromOffset(100, 20)
            Button.Position = UDim2.new(0.5, -50, 0.5, Height)
            Button.Text = Text
            Button.TextStrokeTransparency = 0.8
            Button.TextSize = 14
            Button.Font = Enum.Font.SourceSans
            Button.TextColor3 = Color3.new(1, 1, 1)
            Button.Parent = Prompt
            Button.MouseButton1Click:Connect(function() Prompt:Destroy() Callback(unpack(Arguments)) end)
            CreateStroke(Button, Color3.new(), 1)
            Height += 25
        end
    
        CreateButton("OK", Callback, ...)
        CreateButton("Cancel", function() Prompt:Destroy() end)
    
    
        Title.Name = "Title"
        Title.BackgroundTransparency = 1
        Title.Size = UDim2.new(1, 0, 0, 15)
        Title.Position = UDim2.new(0, 0, 0.5, -100)
        Title.Text = Message
        Title.TextSize = 14
        Title.Font = Enum.Font.SourceSans
        Title.TextColor3 = Color3.new(1, 1, 1)
        Title.Parent = Prompt
    
        Prompt.Name = "Prompt"
        Prompt.BackgroundTransparency = 0.5
        Prompt.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        Prompt.BorderSizePixel = 0
        Prompt.Size = UDim2.new(1, 0, 1, 36)
        Prompt.Position = UDim2.fromOffset(0, -36)
        Prompt.Parent = Menu.Screen
    end
    
    
    function Menu.Spectators(): Spectators
        local Frame = Instance.new("Frame")
        local Title = Instance.new("TextLabel")
        local List = Instance.new("Frame")
        local ListLayout = Instance.new("UIListLayout")
        local Spectators = {self = Frame}
        Spectators.List = {}
        Menu.Spectators = Spectators
    
    
        Frame.Name = "Spectators"
        Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
        Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
        Frame.BorderMode = Enum.BorderMode.Inset
        Frame.Size = UDim2.fromOffset(250, 50)
        Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
        Frame.Visible = false
        Frame.Parent = Menu.Screen
        CreateStroke(Frame, Color3.new(), 1)
        CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
        SetDraggable(Frame)
        
        Title.Name = "Title"
        Title.BackgroundTransparency = 1
        Title.Position = UDim2.new(0, 5, 0, 5)
        Title.Size = UDim2.new(0, 240, 0, 15)
        Title.Font = Enum.Font.SourceSansSemibold
        Title.Text = "Spectators"
        Title.TextColor3 = Color3.new(1, 1, 1)
        Title.TextSize = 14
        Title.Parent = Frame
    
        List.Name = "List"
        List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        List.BorderColor3 = Color3.fromRGB(40, 40, 40)
        List.BorderMode = Enum.BorderMode.Inset
        List.Position = UDim2.new(0, 4, 0, 30)
        List.Size = UDim2.new(0, 240, 0, 10)
        List.Parent = Frame
    
        ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        ListLayout.Parent = List
    
    
        local function UpdateFrameSize()
            local Height = ListLayout.AbsoluteContentSize.Y + 5
            Spectators.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 50, 50, 5000)), nil, nil, 0.3, true)
            Spectators.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
        end
    
    
        function Spectators.Add(Name: string, Icon: string)
            Spectators.Remove(Name)
            local Object = Instance.new("Frame")
            local NameLabel = Instance.new("TextLabel")
            local IconImage = Instance.new("ImageLabel")
            local Spectator = {self = Object}
    
            Object.Name = "Object"
            Object.BackgroundTransparency = 1
            Object.Position = UDim2.new(0, 5, 0, 30)
            Object.Size = UDim2.new(0, 240, 0, 15)
            Object.Parent = List
    
            NameLabel.Name = "Name"
            NameLabel.BackgroundTransparency = 1
            NameLabel.Position = UDim2.new(0, 20, 0, 0)
            NameLabel.Size = UDim2.new(0, 230, 1, 0)
            NameLabel.Font = Enum.Font.SourceSans
            NameLabel.Text = tostring(Name)
            NameLabel.TextColor3 = Color3.new(1, 1, 1)
            NameLabel.TextSize = 14
            NameLabel.TextXAlignment = Enum.TextXAlignment.Left
            NameLabel.Parent = Object
    
            IconImage.Name = "Icon"
            IconImage.BackgroundTransparency = 1
            IconImage.Image = Icon or ""
            IconImage.Size = UDim2.new(0, 15, 0, 15)
            IconImage.Position = UDim2.new(0, 2, 0, 0)
            IconImage.Parent = Object
    
            Spectators.List[Name] = Spectator
            UpdateFrameSize()
        end
    
    
        function Spectators.Remove(Name: string)
            if Spectators.List[Name] then
                Spectators.List[Name].self:Destroy()
                Spectators.List[Name] = nil
            end
            UpdateFrameSize()
        end
    
    
        function Spectators:SetVisible(Visible: boolean)
            self.self.Visible = Visible
        end
    
    
        return Spectators
    end
    
    
    function Menu.Keybinds(): Keybinds
        local Frame = Instance.new("Frame")
        local Title = Instance.new("TextLabel")
        local List = Instance.new("Frame")
        local ListLayout = Instance.new("UIListLayout")
        local Keybinds = {self = Frame}
        Keybinds.List = {}
        Menu.Keybinds = Keybinds
    
    
        Frame.Name = "Keybinds"
        Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
        Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
        Frame.BorderMode = Enum.BorderMode.Inset
        Frame.Size = UDim2.fromOffset(250, 45)
        Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
        Frame.Visible = false
        Frame.Parent = Menu.Screen
        CreateStroke(Frame, Color3.new(), 1)
        CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
        SetDraggable(Frame)
    
        Title.Name = "Title"
        Title.BackgroundTransparency = 1
        Title.Position = UDim2.new(0, 5, 0, 5)
        Title.Size = UDim2.new(0, 240, 0, 15)
        Title.Font = Enum.Font.SourceSansSemibold
        Title.Text = "Key binds"
        Title.TextColor3 = Color3.new(1, 1, 1)
        Title.TextSize = 14
        Title.Parent = Frame
    
        List.Name = "List"
        List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        List.BorderColor3 = Color3.fromRGB(40, 40, 40)
        List.BorderMode = Enum.BorderMode.Inset
        List.Position = UDim2.new(0, 4, 0, 30)
        List.Size = UDim2.new(0, 240, 0, 10)
        List.Parent = Frame
    
        ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        ListLayout.Padding = UDim.new(0, 3)
        ListLayout.Parent = List
    
        local function UpdateFrameSize()
            local Height = ListLayout.AbsoluteContentSize.Y + 5
            Keybinds.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 45, 45, 5000)), nil, nil, 0.3, true)
            Keybinds.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
        end
    
        function Keybinds.Add(Name: string, State: string): Keybind
            Keybinds.Remove(Name)
            local Object = Instance.new("Frame")
            local NameLabel = Instance.new("TextLabel")
            local StateLabel = Instance.new("TextLabel")
            local Keybind = {self = Object}
    
            Object.Name = "Object"
            Object.BackgroundTransparency = 1
            Object.Position = UDim2.new(0, 5, 0, 30)
            Object.Size = UDim2.new(0, 230, 0, 15)
            Object.Parent = List
    
            NameLabel.Name = "Indicator"
            NameLabel.BackgroundTransparency = 1
            NameLabel.Position = UDim2.new(0, 5, 0, 0)
            NameLabel.Size = UDim2.new(0, 180, 1, 0)
            NameLabel.Font = Enum.Font.SourceSans
            NameLabel.Text = Name
            NameLabel.TextColor3 = Color3.new(1, 1, 1)
            NameLabel.TextSize = 14
            NameLabel.TextXAlignment = Enum.TextXAlignment.Left
            NameLabel.Parent = Object
    
            StateLabel.Name = "State"
            StateLabel.BackgroundTransparency = 1
            StateLabel.Position = UDim2.new(0, 190, 0, 0)
            StateLabel.Size = UDim2.new(0, 40, 1, 0)
            StateLabel.Font = Enum.Font.SourceSans
            StateLabel.Text = "[" .. tostring(State) .. "]"
            StateLabel.TextColor3 = Color3.new(1, 1, 1)
            StateLabel.TextSize = 14
            StateLabel.TextXAlignment = Enum.TextXAlignment.Right
            StateLabel.Parent = Object
    
            
            function Keybind:Update(State: string)
                StateLabel.Text = "[" .. tostring(State) .. "]"
            end
    
            function Keybind:SetVisible(Visible: boolean)
                if typeof(Visible) ~= "boolean" then return end
                if Object.Visible == Visible then return end
            
                Object.Visible = Visible
                UpdateFrameSize()
            end
    
            
            Keybinds.List[Name] = Keybind
            UpdateFrameSize()
    
            return Keybind
        end
    
        function Keybinds.Remove(Name: string)
            if Keybinds.List[Name] then
                Keybinds.List[Name].self:Destroy()
                Keybinds.List[Name] = nil
            end
            UpdateFrameSize()
        end
    
        function Keybinds:SetVisible(Visible: boolean)
            self.self.Visible = Visible
        end
    
        function Keybinds:SetPosition(Position: UDim2)
            self.self.Position = Position
        end
    
        return Keybinds
    end
    
    
    function Menu.Indicators(): Indicators
        local Frame = Instance.new("Frame")
        local Title = Instance.new("TextLabel")
        local List = Instance.new("Frame")
        local ListLayout = Instance.new("UIListLayout")
    
        local Indicators = {self = Frame}
        Indicators.List = {}
        Menu.Indicators = Indicators
    
        Frame.Name = "Indicators"
        Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
        Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
        Frame.BorderMode = Enum.BorderMode.Inset
        Frame.Size = UDim2.fromOffset(250, 45)
        Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
        Frame.Visible = false
        Frame.Parent = Menu.Screen
        CreateStroke(Frame, Color3.new(), 1)
        CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
        SetDraggable(Frame)
    
        Title.Name = "Title"
        Title.BackgroundTransparency = 1
        Title.Position = UDim2.new(0, 5, 0, 5)
        Title.Size = UDim2.new(0, 240, 0, 15)
        Title.Font = Enum.Font.SourceSansSemibold
        Title.Text = "Indicators"
        Title.TextColor3 = Color3.new(1, 1, 1)
        Title.TextSize = 14
        Title.Parent = Frame
    
        List.Name = "List"
        List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        List.BorderColor3 = Color3.fromRGB(40, 40, 40)
        List.BorderMode = Enum.BorderMode.Inset
        List.Position = UDim2.new(0, 4, 0, 30)
        List.Size = UDim2.new(0, 240, 0, 10)
        List.Parent = Frame
    
        ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        ListLayout.Padding = UDim.new(0, 3)
        ListLayout.Parent = List
    
        local function UpdateFrameSize()
            local Height = ListLayout.AbsoluteContentSize.Y + 12
            Indicators.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 45, 45, 5000)), nil, nil, 0.3, true)
            Indicators.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
        end
    
        function Indicators.Add(Name: string, Type: string, Value: string, ...): Indicator
            Indicators.Remove(Name)
            local Object = Instance.new("Frame")
            local NameLabel = Instance.new("TextLabel")
            local StateLabel = Instance.new("TextLabel")
    
            local Indicator = {self = Object}
            Indicator.Type = Type
            Indicator.Value = Value
    
            Object.Name = "Object"
            Object.BackgroundTransparency = 1
            Object.Size = UDim2.new(0, 230, 0, 30)
            Object.Parent = Indicators.self.List
            
            NameLabel.Name = "Indicator"
            NameLabel.BackgroundTransparency = 1
            NameLabel.Position = UDim2.new(0, 5, 0, 0)
            NameLabel.Size = UDim2.new(0, 130, 0, 15)
            NameLabel.Font = Enum.Font.SourceSans
            NameLabel.Text = Name
            NameLabel.TextColor3 = Color3.new(1, 1, 1)
            NameLabel.TextSize = 14
            NameLabel.TextXAlignment = Enum.TextXAlignment.Left
            NameLabel.Parent = Indicator.self
        
            StateLabel.Name = "State"
            StateLabel.BackgroundTransparency = 1
            StateLabel.Position = UDim2.new(0, 180, 0, 0)
            StateLabel.Size = UDim2.new(0, 40, 0, 15)
            StateLabel.Font = Enum.Font.SourceSans
            StateLabel.Text = "[" .. tostring(Value) .. "]"
            StateLabel.TextColor3 = Color3.new(1, 1, 1)
            StateLabel.TextSize = 14
            StateLabel.TextXAlignment = Enum.TextXAlignment.Right
            StateLabel.Parent = Indicator.self
    
    
            if Type == "Bar" then
                local ObjectBase = Instance.new("Frame")
                local ValueLabel = Instance.new("TextLabel")
    
                ObjectBase.Name = "Bar"
                ObjectBase.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
                ObjectBase.BorderColor3 = Color3.new()
                ObjectBase.Position = UDim2.new(0, 0, 0, 20)
                ObjectBase.Size = UDim2.new(0, 220, 0, 5)
                ObjectBase.Parent = Indicator.self
        
                ValueLabel.Name = "Value"
                ValueLabel.BorderSizePixel = 0
                ValueLabel.BackgroundColor3 = Menu.Accent
                ValueLabel.Text = ""
                ValueLabel.Parent = ObjectBase
                AddEventListener(ValueLabel, function()
                    ValueLabel.BackgroundColor3 = Menu.Accent
                end)
            else
                Object.Size = UDim2.new(0, 230, 0, 15)
            end
    
    
            function Indicator:Update(Value: string, ...)
                if Indicators.List[Name] then
                    if Type == "Text" then
                        self.Value = Value
                        Object.State.Text = Value
                    elseif Type == "Bar" then
                        local Min, Max = select(1, ...)
                        self.Min = typeof(Min) == "number" and Min or self.Min
                        self.Max = typeof(Max) == "number" and Max or self.Max
    
                        local Scale = (self.Value - self.Min) / (self.Max - self.Min)
                        Object.State.Text = "[" .. tostring(self.Value) .. "]"
                        Object.Bar.Value.Size = UDim2.new(math.clamp(Scale, 0, 1), 0, 0, 5)
                    end
                    self.Value = Value
                end
            end
    
    
            function Indicator:SetVisible(Visible: boolean)
                if typeof(Visible) ~= "boolean" then return end
                if Object.Visible == Visible then return end
                
                Object.Visible = Visible
                UpdateFrameSize()
            end
    
            
            Indicator:Update(Indicator.Value, ...)
            Indicators.List[Name] = Indicator
            UpdateFrameSize()
            return Indicator
        end
    
    
        function Indicators.Remove(Name: string)
            if Indicators.List[Name] then
                Indicators.List[Name].self:Destroy()
                Indicators.List[Name] = nil
            end
            UpdateFrameSize()
        end
    
    
        function Indicators:SetVisible(Visible: boolean)
            self.self.Visible = Visible
        end
    
        function Indicators:SetPosition(Position: UDim2)
            self.self.Position = Position
        end
    
    
        return Indicators
    end
    
    
    function Menu.Watermark(): Watermark
        local Watermark = {}
        Watermark.Frame = Instance.new("Frame")
        Watermark.Title = Instance.new("TextLabel")
        Menu.Watermark = Watermark
    
        Watermark.Frame.Name = "Watermark"
        Watermark.Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
        Watermark.Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
        Watermark.Frame.BorderMode = Enum.BorderMode.Inset
        Watermark.Frame.Size = UDim2.fromOffset(250, 20)
        Watermark.Frame.Position = UDim2.fromOffset((Menu.ScreenSize.X - Watermark.Frame.Size.X.Offset) - 50, -25)
        Watermark.Frame.Visible = false
        Watermark.Frame.Parent = Menu.Screen
        CreateStroke(Watermark.Frame, Color3.new(), 1)
        CreateLine(Watermark.Frame, UDim2.new(0, 245, 0, 1), UDim2.new(0, 2, 0, 15))
        SetDraggable(Watermark.Frame)
    
        Watermark.Title.Name = "Title"
        Watermark.Title.BackgroundTransparency = 1
        Watermark.Title.Position = UDim2.new(0, 5, 0, -1)
        Watermark.Title.Size = UDim2.new(0, 240, 0, 15)
        Watermark.Title.Font = Enum.Font.SourceSansSemibold
        Watermark.Title.Text = ""
        Watermark.Title.TextColor3 = Color3.new(1, 1, 1)
        Watermark.Title.TextSize = 14
        Watermark.Title.RichText = true
        Watermark.Title.Parent = Watermark.Frame
    
        function Watermark:Update(Text: string)
            self.Title.Text = tostring(Text)
        end
    
        function Watermark:SetVisible(Visible: boolean)
            self.Frame.Visible = Visible
        end
    
        return Watermark
    end
    
    
    function Menu:Init()
        UserInput.InputBegan:Connect(function(Input: InputObject, Process: boolean) end)
        UserInput.InputEnded:Connect(function(Input: InputObject)
            if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
                Dragging = {Gui = nil, True = false}
            end
        end)
        RunService.RenderStepped:Connect(function(Step: number)
            local Menu_Frame = Menu.Screen.Menu
            Menu_Frame.Position = UDim2.fromOffset(
                math.clamp(Menu_Frame.AbsolutePosition.X,   0, math.clamp(Menu.ScreenSize.X - Menu_Frame.AbsoluteSize.X, 0, Menu.ScreenSize.X    )),
                math.clamp(Menu_Frame.AbsolutePosition.Y, -36, math.clamp(Menu.ScreenSize.Y - Menu_Frame.AbsoluteSize.Y, 0, Menu.ScreenSize.Y - 36))
            )
            local Selected_Frame = Selected.Frame
            local Selected_Item = Selected.Item
            if (Selected_Frame and Selected_Item) then
                local Offset = Selected.Offset or UDim2.fromOffset()
                local Position = UDim2.fromOffset(Selected_Item.AbsolutePosition.X, Selected_Item.AbsolutePosition.Y)
                Selected_Frame.Position = Position + Offset
            end
        
            if Scaling.True then
                MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
                local Origin = Scaling.Origin
                local Size = Scaling.Size
        
                if Origin and Size then
                    local Location = UserInput:GetMouseLocation()
                    local NewSize = Location + (Size - Origin)
        
                    Menu:SetSize(Vector2.new(
                        math.clamp(NewSize.X, Menu.MinSize.X, Menu.MaxSize.X),
                        math.clamp(NewSize.Y, Menu.MinSize.Y, Menu.MaxSize.Y)
                    ))
                end
            else
                MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
            end
        
            Menu.Hue += math.clamp(Step / 100, 0, 1)
            if Menu.Hue >= 1 then Menu.Hue = 0 end
        
            if ToolTip.Enabled == true then
                ToolTip_Label.Text = ToolTip.Content
                ToolTip_Label.Position = UDim2.fromOffset(ToolTip.Item.AbsolutePosition.X, ToolTip.Item.AbsolutePosition.Y + 25)
            end
        end)
        Menu.Screen:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
            Menu.ScreenSize = Menu.Screen.AbsoluteSize
        end)
    end--
